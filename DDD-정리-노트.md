## DDD (Domain Driven Design)
소프트웨어로 문제를 해결하기 위한 방법론

## 유비쿼터스 언어
- 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.
- 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 절약한다.
- 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.
- 즉, 프로젝트 어디에서나 공통으로 사용되는 언어

<br>

## BOUNDED CONTEXT
- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.
- 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
- 모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 BOUNDED CONTEXT라고 부른다.

### 좋은 BOUNDED CONTEXT
- 하나의 BOUNDED CONTEXT는 하나의 팀에만 할당되어야 한다.
    - 하나의 팀은 여러 개의 BOUNDED CONTEXT를 다룰 수 있다.
- 각각의 BOUNDED CONTEXT는 각각의 개발 환경을 가질 수 있다.


<br>

## 도메인 주도 설계 기본 요소
도출한 모델은 크게 엔티티(Entity)와 밸류(Value Object)로 구분
데이터와 함께 도메인 기능 제공

<br>

### VALUE OBJECT

- 밸류 타입은 불변
- 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용
- 시스템이 성숙함에 따라 데이터 값을 객체로 대체
- 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.
- 정말 String으로 우편 번호를 표현할 수 있는가?
- 항상 equals() 메서드를 오버라이드할 것을 권고한다.

> equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java

<hr>

### Entity
- 식별자를 갖는다.
- 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.

### 도메인 모델에 set 메서드 넣지 않기
- 도메인 모델에 get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇
- 특히 set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- set 메서드의 또 다른 문제는 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.

<hr>

### Aggregate
관련 객체를 하나로 묶은 군집

- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다.


### 애그리거트 루트

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.

### 애그리거트 참조

- 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다.
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다,
- ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.


### 리포지터리
- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델
- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.
- 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException과 같은 문제가 발생하게 된다.
- 리포지토리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다.


<hr>

### 표현 영역
- 사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어
- 사용자가의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

### 응용 서비스 (Application Layer)
- 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용한다.
- 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
- 도메인 객체 간의 실행 흐름을 제어
- 트랜잭션 처리
- 도메인 영역에서 발생시킨 이벤트를 처리

```java
public Result doSomeFunc(SomeReq req) {
    // 1. 리포지터리에서 애그리거트를 구한다.
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);
    // 2. 애그리거트의 도메인 기능을 실행한다.
    agg.doFunc(req.getValue());
    // 3. 결과를 리턴한다.
    return createSuccessResult(agg);
}
```

<hr>

## 의존 역전 원칙

### 고수준 모듈, 저수준 모듈

#### 고수준 모듈
- 어떤 의미 있는 단일 기능을 제공하는 모듈
- e.g. 가격 할인 계산

#### 저수준 모듈
- 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
- e.g. 가격 할인 계산

```
1. 고객 정보를 구한다. = RDBMS에서 JPA로 구한다.
2. 룰을 이용해서 할인 금액을 구한다. = Drools로 룰을 적용한다.
```

### 고수준 모듈의 의존 문제
- 고수준 모듈이 저수준 모듈을 의존
- 저수준 모듈의 변경에 따라 고수준 모듈이 영향을 받는다.
- 고수준 모듈만 테스트하기 어렵다.
- 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야 한다.

### DIP
- 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle, 의존 역전 원칙)라고 부른다.
- 인프라스트럭처 영역에 의존할 때 발생했던 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소할 수 있다.
- 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.