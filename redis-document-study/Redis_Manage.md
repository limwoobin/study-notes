# Redis Manage

## Redis Sentinel 을 통한 고가용성

- 모니터링 : Sentinel은 마스터 및 복제본 인스턴스가 예상대로 작동하는지 지속적으로 확인합니다.
- 알림 : Sentinel은 모니터링되는 Redis 인스턴스 중 하나에 문제가 있음을 API를 통해 시스템 관리자나 다른 컴퓨터 프로그램에 알릴 수 있습니다.
- 자동 장애 조치 : 마스터가 예상대로 작동하지 않는 경우 Sentinel은 복제본이 마스터로 승격됩니다.
- 구성 공급자 : Sentinel은 클라이언트 서비스 검색을 위한  소스 역할을 합니다.  
클라이언트는 Redis 마스터의 주소를 요청하기 위해 Sentinel에 연결합니다. 장애 조치가 발생하면 Sentinels는 새 주소를 보고합니다.



## Redis Replication
- 레디스는 비동기(asynchronous) 복제를 합니다.
- 마스터는 Replica Server 를 여러 개 둘 수 있습니다.
- Replica Server 는 또 다른 Replica Server 를 둘 수 있습니다.
- Master -> Replica1 -> Replica2 이런 구성이 됩니다.
- 마스터에 많은 데이터가 있는 상태에서 Replica Server 를 구성하면, 대량의 데이터가 Replica Server 로 보내질것입니다.  
이 때에도 마스터는 멈추지 않고 정상적으로 요청을 처리합니다. 왜냐하면 데이터를 Replica Server 로 보내는(RDB 파일을 생성하는) 작업은 자식 프로세스가 처리하기 때문입니다.
- Replica Server 에서 조회 요청을 처리하도록 하는 것도 부하분산을 위한 좋은 방법입니다.  
특히 SORT 명령같은 것들은 복제서버에서 수행하는 것이 좋습니다.
- 마스터의 부하를 줄이기 위해서, AOF 쓰기나 RDB 파일 생성을 Replica Server 에서 수행하는 것도 좋은 방법입니다.  
하지만 이런 설정을 했을 경우에는 마스터 자동 시작 하도록 하면 데이터가 유실 될 수 있습니다.

### 전체 동기화 (Full Synchronization)

- 복제 순서
    1. 마스터는 자식 프로세스를 시작해 백그라운드로 RDB파일에 데이터를 저장합니다.
    2. 데이터를 저장하는 동안 마스터에 새로 들어온 명령들은 처리 후 복제 버퍼에 저장됩니다.
    3. RDB 파일 저장이 완료되면, 마스터는 파일을 복제 서버에게 전송합니다.
    4. 복제서버는 파일을 받아 디스크에 저장하고, 메모리로 로드합니다.
    5. 마스터는 복제 버퍼에 저장된 명령을 복제서버에게 전송합니다.

- 레디스 2.8.18 부터는 RDB 파일을 디스크에 만들지 않고 복제하는 기능을 제공합니다. (디스크 대신 소켓을 이용함)
- 마스터가 살아나면 복제서버에 복제 순서에 따라 Sync를 합니다. 복제서버가 여러 개 일때도 RDB 파일은 하나만 생성합니다.


### 부분 동기화 (Partial reSynchronization)

- 마스터와 복제서버는 각 서버의 run id 와 replication offset을 가지고 있습니다.  
마스터와 복제서버간 네트워크가 끊어지면 마스터는 복제서버에 전달할 데이터를 `backlog-buffer` 에 저장합니다. 
- 다시 연결되었을 때 `backlog-buffer` 가 넘치지 않았으면 run id와 offset을 비교해서 그 이후 부터 동기화를 합니다. 이것을 부분 동기화라고 합니다.  
`Backlog-buffer` 크기는 `repl-backlog-size` 파라미터로 설정합니다.  
부분 동기화 기능은 레디스 버전 2.8 부터 제공됩니다.

- 네크워트 단절 시간이 길어져 마스터의 `backlog-buffer` 가 넘치면 다시 연결되었을 때 __전체 동기화(full synchronization)__ 를 합니다.  
마스터나 복제서버 중 한쪽이 재시작했을 경우에도 전체 동기화를 합니다.


## Redis Persistence

- RDB (Redis 데이터베이스): RDB 는 특정 간격으로 메모리에 있는 레디스 데이터 전체를 디스크에 씁니다.  
(특정 시점 마다 백업을 받을 때 사용)
- AOF (Append Only File): AOF 는 서버에서 수신한 모든 쓰기 작업을 기록합니다. 즉, 명령이 실행될 때마다 기록됩니다. 데이터 손실이 거의 없습니다.
- RDB + AOF : 동일한 인스턴스에서 AOF와 RDB를 결합할 수도 있습니다.

### AOF (Append Only File)

- AOF 파일은 default로 `appendonly.aof` 파일에 기록됩니다. 입력/수정/삭제 명령이 실행될 때 마다 기록됩니다. 조회 명령은 기록되지 않습니다. 
- AOF는 계속 추가하면서 기록됩니다. 하지만 특정 시점에 데이터 전체를 다시 쓰는 기능이 있습니다.(rewrite)  
왜 이런 기능이 필요할까요? AOF는 계속 추가하면서 기록되기 때문에 파일 사이즈가 계속 커집니다.  
너무 커지면 OS 파일 사이즈 제한에 걸러서 기록이 중단될 수도 있고, 레디스 서버 시작 시 로드 시간이 많이 걸릴 수 있습니다.
그럼 rewrite 하면 파일 사이즈가 작아 질까요? 작아집니다.  
예를 들어 SET 명령이 key는 같고 값을 다른 조건에서 5번 수행되었다고 하면, 메모리에는 마지막 수행된 값만 남아있습니다. 하지만 AOF에는 5번 모두 남아 있습니다. 다른 대표적인 명령은 INCR 입니다. INCR key가 1000번 수행되었다고 하면 메모리에는 key 1000 이 하나만 남아 있습니다. AOF에는 INCR key 명령이 1000번 기록되어 있습니다. Rewrite를 수행하면 이전 기록은 모두 사라지고 최종 데이터가 기록됩니다. 즉, INCR key 1000번은 SET key 1000 하나로 기록됩니다.
- AOF 파일은 text 파일이므로 edit 가능합니다. 실수로 `FLUSHALL` 명령으로 메모리에 있는 데이터 전체를 날렸을 경우, 즉시 레디스 서버를 shutdown하고, `appendonly.aof` 파일에서 `FLUSHALL` 명령을 제거 한 후 레디스를 다시 시작하면 데이터 손실없이 DB를 살릴 수 있습니다.

### RDB (Snapshot)

- RDB는 특정 시점의 메모리에 있는 데이터 전체를 바이너리 파일로 저장하는 것이다.  
AOF 파일보다 사이즈가 작다. 따라서 로딩 속도가 AOF 보다 빠르다.
일반적으로 AOF 가 10초 걸린다면, RDB는 7초 정도로 생각하면 될 것이다.
- 저장 시점을 정하는 `redis.conf` 의 파라미터는 save 이다.
SAVE 조건은 여러 개를 지정할 수 있고, 모두 or 조건이다. 즉 어느 것 하나라도 만족하면 저장한다.

```
save 900 1   900초(15분) 동안 1번 이상 key 변경이 발생하면 저장 
save 300 10   300초(5분) 동안 10번 이상 key 변경이 발생하면 저장 
save 60 10000   60초(1분) 동안 10000번 이상 key 변경이 발생하면 저장 
```

### 어느 것을 선택할까

- AOF를 기본으로 하고, RDB를 Option으로 한다.  
AOF 시간 설정은 everysec(1초 마다)로 하고, AOF Rewrite를 사용한다.  
AOF를 사용해도 성능에 거의 영향을 미치지 않는다.

- Master 노드이고 Auto-restart 기능을 사용할때는 AOF를 사용하는 것이 안전하다. Master 노드가 자동 재시작했을때 AOF 파일은 없고, 몇 분 전 RDB 파일만 있다면 slave 노드들의 데이터도 마스터와 같이 몇 분 전 RDB 파일의 데이터를 받게 된다. 이때 유실이 발생하게 된다.