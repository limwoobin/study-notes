# ETC

## 신입이 어떻게 대규모 트래픽 처리 경험을 쌓아요? https://www.youtube.com/watch?v=b4Ro_2cK9V8

채용공고의 대규모 트래픽 경험 우대인 경우에서 대규모 트래픽 경험이 없어도 이 부분을 대비할 수 있는 방법은?

- 대규모의 규모에 대해서는 정량적이지 않기때문에 먼저 내가 생각하는 대규모에 대해서 정의한다
- 대규모에 대해서 어떻게 어느정도를 측정할지? (Traffic, Latency, CPU, Memory, Disk ...)
	- 모니터링 도구를 이용해 파악 가능
	- Jmeter, Ngriner 와 같은 성능테스트를 통해 테스트 해볼 수 있을듯
- 부하를 만들어보고 생기는 병목지점에 대해 SQL 튜닝 혹은 캐싱을 이용해 개선해보는 경험기를 만들어보자
- 인터뷰어는 공공데이터들을 이용해서 전처리 및 시각화를 하는 프로젝트를 진행했다고함



## N + 1
@OneToOne 에서 연관관계 주인이 아닌곳에서 엔티티를 조회하게 되면 
@OneToOne 관계의 엔티티가 LazyLoading 으로 설정되어있더라도 N+1 이 발생하게된다.

이유 > 연관관계 주인이 아닌곳에서는 상대의 FK 를 모르기에 상대객체가 NULL 일 수가 있다.
그래서 이때 객체입장에선 이 객체를 프록시로 할당할지 NULL 로 할당할지 알 수 없는 상황이다.
그래서 Lazy 로 동작하지 않고 바로 Eager 로 쿼리를 실행해 해당 객체에 대해 어떤 값인지 알게끔 처리된다 
+ (프록시는 Null 을 감쌀수 없어서 둘 중 어떤 값으로든 넣기 애매한 상황이 발생한다)



## message

at_least_once : 이벤트가 발생했을 때, 해당 이벤트가 최소 1번은 이벤트가 발행되어 
처리되는 것을 보장을 한다는 의미
- 메시지 유실을 방지하기 위해 중복으로 메시지를 처리하는 것을 허용하는 것

at_most_once : 이벤트가 발생했을 때, 최대 1번만 이벤트 메시지가 발행되게 한다는 의미
- 메세지 유실을 허용하고 중복으로 이벤트 처리를 방지하기 위한 것

## Spring Event

- 이벤트를 왜 쓰나?
의존성을 분리하기 위해
e.g) 유저를 저장할때 유저 히스토리도 저장하는데 이때 히스토리를 저장하는 책임은 분리한다
왜? 히스토리 저장에서 장애가 나게되면 이 히스토리때문에 유저도 저장하지 못하는 이슈가 있다.
즉, 유저 저장과 히스토리 저장의 의존성(결합도)를 분리하는것

- TaskExecutor 를 직접 빈으로 등록하는 이유
- @Transactional
- Spring AOP 와 프록시
- 언제 사용하면 좋을지


## DNS TCP, UDP
- DNS: 사람이 읽을 수 있는 도메인을 머신이 읽을수 있는 IP 주소로 변환
	- e.g) naver.com -> 192.0.2.44
- DNS 는 기본적으로 UDP 를 사용함, 왜냐면 DNS 는 일반적으로 512 바이트 미만의 데이터를 처리하고
신뢰성보다 속도가 중요한 서비스이기에
- 하지만 간혹 TCP 를 사용하는 경우도 있음
	- 메시지 크기가 512 바이트보다 큰 경우 (DNS 는 512byte 크기 제한이 있음)
	- zone 정보 동기화 하는 경우(master 와 slave 간에) -> zone-transfer
	- zone-transfer: DNS 트랜잭션의 한 유형으로 여러대의 DNS 서버간에 DNS 데이터베이스를 복제하는데 사용되는 방법


## Redis 야무지게 사용하기

#### 사용하면 안되는 커맨드
- `keys *` 사용하지 않기, `keys * -> scan` 으로 대체
- `hgetall -> hscan`
- `del -> unlink`

#### 변경하면 장애를 막을 수 있는 기본 설정값

`STOP-WRITES-ON-BGSAVE-ERROR = NO`
- 기본값은 yes
- RDB 파일 저장 실패시 redis 로의 모든 write 를 불가능하게 하는것
- 이 설정을 꺼두는게 오히려 장애를 막을 수 있는 방법일 수 있다

`MAXMEMORY-POLICY = ALLKEYS-LRU`
- 메모리가 가득 찼을때 MAXMEMORY-POLICY 정책에 의해 키가 관리됨
	- 기본값은 noeviction : 삭제안함 이다, 이는 메모리가 가득차면 아무액션을 하지않기에 에러가 발생할듯
	- allkeys-lru 같은 설정을 쓰자
	- volatile-lru 는 ttl 이 있는 key 만 삭제하기에 ttl 이 없다면 동일상황이 발생할 수 있음
- redis 를 캐시로 사용할때 Expire Time 설정 권장

#### Persistence / 복제 사용 시 MaxMemory 설정 주의
- Copy-on-Write 로 인해 메모리 복재할때 메모리를 두개 가량 사용하는 경우가 발생할 수 있음
- 그렇기에 Persistence / 복제 사용시 MAXMEMORY 는 실제 메모리의 절반으로 설정하는게 안전
e.g) 4GB -> 2G (2048MB)


#### Memory 관리

물리적으로 사용되고 있는 메모리를 모니터링
used_memory 값 보다 used_memory_rss 값을 보는게 더 중요하다

- used_memory: 논리적으로 Redis 가 사용하는 메모리
- used_memory_rss: OS 가 Redis 에 할당하기 위해 사용한 물리적 메모리 양
- 삭제되는 키가 많으면 fragmentation 증가
	- 특정 시점에 피크를 찍고 다시 삭제되는 경우
	- TTL 로 인한 eviction 이 많이 발생하는 경우

#### 레디스 클러스터에서는 레디스 트랜잭션을 사용할 수 없는듯??

#### 레디스 동작 및 스레드
- 레디스는 싱글스레드이다, 정확히는 메인 스레드1개와 별도 스레드 3개로 동작한다.
- 클라이언트 커맨드를 처리하는 부분은 이벤트 루프를 이용한 싱글 스레드로 동작한다.
	- 멀티스레드 어플리케이션에서 요구되는 동기화나 잠금 메커니즘이 없어 빠르게 요청을 처리할 수 있다.
	- 별도 스레드는 일반적으로 I/O 작업이나 데이터 백업작업을 진행함

<hr />
<br />

## 리눅스 중요 명령어

### IP 를 확인하는 명령어, 자신의 Public IP 는 어떻게 확인하나요?
- 대표적으로는  curl ifconfig.co, curl ifconfig.me

### CURL 의 옵션별 사용법

### Domain 의 IP 를 조회하는 명령어는?
- nslookup

### 웹서버 혹은 DB 같은 서버들을 확인하는 방법
- telnet 과 ping 을 구분하는 의도

### 내 서버의 서버가 잘 떠있는지, 현재 DB 커넥션 등을 확인하는 명령어는?
- netstat 명령어와 그 옵션들을 잘 아는지에 대한 의도임
- netstat -lntp
- netstat -an | grep "port"

### 리눅스에서 특정 프로세스를 확인하는 명령어는?
- ps 명령어
- ps -ef | grep ""
- ps -aux | grep ""

### 리눅스에서 CPU, Memory, Disk 등 시스템 정보를 확인하는 명령어는?
- top, sar, free, df ...

### 리눅스에서 서비스들은 어떻게 관리되고, 그와 연관된 명령어는?
- service, sysctl, systemd 명령어

### 리눅스 파일권한 체계를 이해하고 있는지?
- chmod, chown 에 대한 질문

<hr />
<br />

Kafka 

Transactional Outbox Pattern은 분산 시스템에서 데이터베이스 트랜잭션과 메시지 큐를 조합하여 데이터 일관성과 메시지 전송의 원자성을 보장하는 패턴


<hr />
<br />

# CPU Bound , I/O Bound

Burst
- 어떤 현상이 짧은 시간안에 집중적으로 일어나는 일
- 계속되는 작업

CPU Burst
- 프로세스가 CPU 에서 한번에 연속적으로 실행되는 시간
- 메모리에 올라가있는 프로세스가 자신의 차례가 되어 CPU 에서 실행될때 연속적으로 실행되는 시간

I/O Burst
- 프로세스가 I/O 작업을 요청하고 결과를 기다리는 시간

CPU Bound 프로세스
- CPU Burst 가 많은 프로세스 -> CPU 를 많이 사용하는 프로세스
- e.g) 동영상 편집 프로그램(그래픽 작업), 머신러닝 프로그램, 엄청난 계산이 필요한 어플리케이션
- 성능 향상을 위해서는 scale-up 이 주로 사용됨

I/O Bound 프로세스
- I.O Burst 가 많은 프로세스 -> I/O 를 많이 사용하는 프로세스
- 입출력 시스템(키보드, 마우스 등등), 디스크 드라이브, 네트워크 작업, 주변 장치와 같은 리소스에 의존하는 경우가 I/O Bound
- 입출력 시스템에서 데이터를 읽고 쓰고 정보를 기다리는 모든 애플리케이션은 I/O 바운드로 간주됨
ㄴ 워드 프로세싱 시스템, 웹 어플리케이션, 파일 복사 및 다운로드 등
- e.g) 백엔드 API 서버 -> DB 서버, 캐시서버 등등 요청을 보내는 경우가 많음
- 성능 향상을 위해서는 스레드 수를 최적화한다(주로 scale-out)

+ 프로세스를 실행하면 CPU Burst 와 I/O Burst 가 번갈아가면서 나타난다
+ 일부 프로그램이나 작업은 CPU 와 I/O 에 모두 속한다

적절한 스레드의 개수는?
CPU Bound
- 스레드가 너무 많으면 스레드끼리 코어를 사용하기 위해 경합하면서 컨텍스트 스위칭이 발생해 오버헤드가 커질 수 있음
- 그러니 코어의 개수 혹은 코어의 개수에서 크게 벗어나지 않는 선(1개 정도?)에서 스레드 개수를 설정하는것이 효유렂ㄱ

I/O Bound
- 정해진 가이드는 없어서 경험적으로 최적의 스레드 개수를 찾아야 한다
- 중요한것은, 스레드가 무조건 많다고 해서 성능이 좋은것은 아니다, 오히려 컨텍스트 스위칭이라는 오버헤드가 발생해서 성능이 저하될 수 있다

- https://www.baeldung.com/cs/cpu-io-bound

<br />
<hr />

# park() vs unpark()
- 다른말로 마운트, 언마운트라고 한다

park()
- 스레드를 멈추게한다(블록시킨다)
- 스레드가 깨어날때까지 멈추어있는데
- 스레드가 park 상태에 있을때는 다른 스레드에 의해 unpark 되거나 인터럽트되기 전까지는 깨어나지 않는다.

unpark()
- 스레드를 깨운다
- 특정 스레드를 깨워서 다시 실행가능상태로 만든다
- unpark 는 스레드가 park 메서드에 의해 멈춰있지 않은 경우에도 호출할 수 있음
이러한 경우에는 쓰레드가 park 메서드가 호출될때까지 멈추지않고 계속 실행될 수 있게 해줌

