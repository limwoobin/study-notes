# ETC

## 신입이 어떻게 대규모 트래픽 처리 경험을 쌓아요? https://www.youtube.com/watch?v=b4Ro_2cK9V8

채용공고의 대규모 트래픽 경험 우대인 경우에서 대규모 트래픽 경험이 없어도 이 부분을 대비할 수 있는 방법은?

- 대규모의 규모에 대해서는 정량적이지 않기때문에 먼저 내가 생각하는 대규모에 대해서 정의한다
- 대규모에 대해서 어떻게 어느정도를 측정할지? (Traffic, Latency, CPU, Memory, Disk ...)
	- 모니터링 도구를 이용해 파악 가능
	- Jmeter, Ngriner 와 같은 성능테스트를 통해 테스트 해볼 수 있을듯
- 부하를 만들어보고 생기는 병목지점에 대해 SQL 튜닝 혹은 캐싱을 이용해 개선해보는 경험기를 만들어보자
- 인터뷰어는 공공데이터들을 이용해서 전처리 및 시각화를 하는 프로젝트를 진행했다고함



## N + 1
@OneToOne 에서 연관관계 주인이 아닌곳에서 엔티티를 조회하게 되면 
@OneToOne 관계의 엔티티가 LazyLoading 으로 설정되어있더라도 N+1 이 발생하게된다.

이유 > 연관관계 주인이 아닌곳에서는 상대의 FK 를 모르기에 상대객체가 NULL 일 수가 있다.
그래서 이때 객체입장에선 이 객체를 프록시로 할당할지 NULL 로 할당할지 알 수 없는 상황이다.
그래서 Lazy 로 동작하지 않고 바로 Eager 로 쿼리를 실행해 해당 객체에 대해 어떤 값인지 알게끔 처리된다 
+ (프록시는 Null 을 감쌀수 없어서 둘 중 어떤 값으로든 넣기 애매한 상황이 발생한다)



## message

at_least_once : 이벤트가 발생했을 때, 해당 이벤트가 최소 1번은 이벤트가 발행되어 
처리되는 것을 보장을 한다는 의미
- 메시지 유실을 방지하기 위해 중복으로 메시지를 처리하는 것을 허용하는 것

at_most_once : 이벤트가 발생했을 때, 최대 1번만 이벤트 메시지가 발행되게 한다는 의미
- 메세지 유실을 허용하고 중복으로 이벤트 처리를 방지하기 위한 것

## Spring Event

- 이벤트를 왜 쓰나?
의존성을 분리하기 위해
e.g) 유저를 저장할때 유저 히스토리도 저장하는데 이때 히스토리를 저장하는 책임은 분리한다
왜? 히스토리 저장에서 장애가 나게되면 이 히스토리때문에 유저도 저장하지 못하는 이슈가 있다.
즉, 유저 저장과 히스토리 저장의 의존성(결합도)를 분리하는것

- TaskExecutor 를 직접 빈으로 등록하는 이유
- @Transactional
- Spring AOP 와 프록시
- 언제 사용하면 좋을지


## DNS TCP, UDP
- DNS: 사람이 읽을 수 있는 도메인을 머신이 읽을수 있는 IP 주소로 변환
	- e.g) naver.com -> 192.0.2.44
- DNS 는 기본적으로 UDP 를 사용함, 왜냐면 DNS 는 일반적으로 512 바이트 미만의 데이터를 처리하고
신뢰성보다 속도가 중요한 서비스이기에
- 하지만 간혹 TCP 를 사용하는 경우도 있음
	- 메시지 크기가 512 바이트보다 큰 경우 (DNS 는 512byte 크기 제한이 있음)
	- zone 정보 동기화 하는 경우(master 와 slave 간에) -> zone-transfer
	- zone-transfer: DNS 트랜잭션의 한 유형으로 여러대의 DNS 서버간에 DNS 데이터베이스를 복제하는데 사용되는 방법


## Redis 야무지게 사용하기

1. Redis 캐시로 사용하기
2. Redis 데이터 타입
3. Redis 데이터 영구 저장(RDB vs AOF)