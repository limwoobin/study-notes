1권

# Chapter 01

## 캐시
캐시데이터 방출(evict) 전략
- LRU
- LFU
- FIFO

# Chapter 02

- 메모리는 빠르지만 디스크는 아직도 느리다
- 디스크 탐색은 가능한 피하라
- 단순한 압축 알고리즘은 빠르다
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라
- 데이터 센터는 보통 여러 지역(region) 에 분산되어 있고, 센터들 간에 데이터를 주고받는데는 시간이 걸린다.

- 면접에서 중요한것은 정답이 아니라 문제를 해결해나가는 과정이다.
- 이는 정답을 찾기보단 근사치를 활용하듯 접근하자
- 많이 출제되는 규모 추정 문제는 QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정하는 것이다. 이런 값들을 계산하는 연습을 하자
	- QPS(Query Per Second): DB가 초당 실행하는 Query 실행량, 초당 실행하는 쿼리 횟수
	- TPS(Transaction Per Second): DB가 초당 실행하는 트랜잭션, 초당 실행하는 업무(작업)의 수


# Chapter 03 시스템 설계 면접 공략법
- 시스템 설계 면접은 두 명의 동료가 모호한 문제를 풀기 위해 협력하며 그 해결책을 찾아내는 과정에 대한
시뮬레이션이다.
- 이 문제에는 정해진 결말도, 정답도 없다.
- 설계면접은 우리의 설계 기술을 시연하며, 설계 과정에서 내린 결정들에 대한 방어 능력을 보이는 자리이다

1단계: 문제 이해 및 설계 범위 확정
- 요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 매우 부정적인 신호다
- 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하라
- 요구사항을 이해하고 모호함을 없애자
- 예시 질문
	- 구체적으로 어떤 기능들을 만들지?
	- 제품 사용자 수는 얼마나 되는지?
	- 회사가 주로 사용하는 기술스택은? 설계를 단순화하기 위해 활용할 수 있는 기존서비스는 어떤것들이 있는지?

2단계: 개략적인 설계안 제시 및 동의 구하기
- 화이트보드같은곳에 핵심 컴포넌트를 포함하는 다이어그램을 그리자
	- 클라이언트, API, 웹 서버, DB, 캐시, CDN, Message Queue 등이 포함될 수 있다

3단계: 상세 설계
- 설계 대상 컴포넌트 사이의 우선순위를 정해야 한다

4단계: 마무리
- 이 단계에선 몇가지 후속질문 혹은 추가 논의를 진행할 수 있다
- 시스템 병목구간, 혹은 추가 개선 가능지점을 찾아내라 할 수 있다.

해야 할 것.
- 질문을 통해 확인하자, 스스로 내린 가정이 옳다 믿고 진행하지 말자
- 문제의 요구사항을 이해하라
- 정답이나 최선의 답안같은것은 없다
- 면접관이 나의 사고흐름을 이해할 수 있게 면접관과 소통하자
- 가능하면 여러 해법을 제시하자
- 개략적 설계에 면접관의 동의하면, 각 컴포넌트의 세부사항을 설명하자 (가장 중요한것부터)
- 면접관의 아이디어를 이끌어내라

하지 말아야 할 것
- 요구사항이나 가정들을 분명히 하지 않을 상태에서 설계를 제시하지 말자
- 처음부터 특정 컴포넌트의 세부사항을 너무 깊이 설명하지 말자, 개략적 설계를 마친 뒤 세부사항으로 이어 나가자
- 침묵속에 설계를 진행하지말고, 소통해라
- 막혔다면 힌트를 청하기를 주저하지 마라
- 의견을 자주 구하고, 설계안을 내놓았다고 면접이 끝났다 생각하지 마라


# Chapter04 - 처리율 제한 장치의 설계 (Rate Limiter)

- DOS 공격에 의한 자원 고갈을 방지할 수 있다
- 비용을 절감할 수 있다
- 서버 과부하를 막는다
	- 봇에서 오는 트래픽이나 사용자의 잘못된 패턴으로 유발된 트래픽을 걸러낼 수 있다


# Chapter05 - 안정 해시

캐시서버를 모듈러 연산을 통해 설계하게되면 균등하게 분배되지만 캐시서버가 추가되거나 제거되었을때
키가 재분배되는데 이때 대규모 캐시 미스가 발생할 수 있다

캐시 링
-  원형의 공간에 캐시 서버들이 있고 캐시 키(데이터)들이 존재하는데 이때 키들은 시계방향으로 가면서 처음 만난 캐시서버에 저장되게끔 처리, 이러면 서버 추가/삭제에 대해 일부분의 데이터만 이동해도됨
- 단점은 캐시 서버간에 파티션(크기)를 균등하게 유지하기가 힘듬
- 그래서 가상노드를 사용해 균등하게 분포하게 함

# Chapter06 - 키-값 저장소 설계

[데이터 파티션]
- 데이터를 작은 파티션으로 분할한 다음 여러 서버에 저장하는 것
- 따져봐야 할것
	- 데이터를 여러 서버에 고르게 분산할 수 있는지
	- 노드가 추가되거나 삭제될떄 데이터 이동을 최소화할 수 있는지
- 안정해시가 이런 기술에 해당됨

[데이터 다중화]
- 고가용성과 안정성을 위해 데이터를 N개 서버에 비동기적으로 다중화하는것

# Chapter07 - 분산 시스템을 위한 유일 ID 생성기 설계

트위터의 스노플레이크 접근법

구성
- 사인 비트
- 타임스탬프
- 데이터센터 ID
- 서버 ID
- 일련번호

# Chapter08 - URL 단축기 설계
URL 단축키란 어떤 URL 를 짧은 URL 로 만들어주는것.
e.g) https://devoong2.tistory.com/ -> https://zrr.kr/e1rm

동작방식
1. https://zrr.kr/e1rm 로 요청을 보낸다
2. zrr.kr 도메인에선 응답을 HttpStatus 301, 원래 URL 인 https://devoong2.tistory.com/ 을 LocationHeader 에 넣어 응답
3. 클라이언트는 응답받은 LocationHeader 의 URL 로 리디렉션

HttpStatus 301 Permanently Moved
- 해당 URL 에 대한 HTTP 요청의 처리 책임이 영구적으로 Location Header 에 반환된 URL 로 이전되었다는 응답
- 영구적으로 이전되었으므로 브라우저는 이 응답을 캐싱함
- 따라서, 이후 동일한 단축 URL 에 요청을 보낼경우 브라우저는 캐시된 원래 RUL 로 요청을 보냄

HttpStatus 302 Found
- 주어진 URL 로의 요청이 일시적으로 LocationHeader 가 지정하는 URL 에 의해 처리되어야 한다는 응답
- 따라서, 클라이언트는 언제나 단축 URL 서버에 먼저 보내진 후 원래 URL 로 리디렉션되어야 함

- Base62 를 사용해 단축URL 을 만들자
- short url / long url 을 캐싱해 성능을 높이자

# Chapter09 - 웹 크롤러 설계

흠...

# Chapter10 - 알림 시스템 설계

범위 확정
Q. 어떤 종류의 알림을 지원해야 하는지?
A. 푸시, SMS, 이메일

Q. 실시간 시스템이어야 하는지?
A. 연성 실시간 시스템이다 > 가능한 빨리 전달되어야하지만 시스템 부하시 약간의 지연은 무방함

Q. 어떤 종류의 단말을 지원하는지?
A. IOS, 안드로이드, 랩톱/데스크톱 지원

Q. 사용자가 알림을 받지 않도록 설정할수있는지?
A. 가능하다

Q. 하루에 몇건의 알림을 보낼수 있어야 하는지?
A. 천만건의 모바일 푸시알림, 백만건의 SMS 메시지, 5백만건의 이메일

# Chapter11 - 뉴스 피드 시스템 설계

범위 확정
Q. 모바일 앱을 지원하나요 아니면 웹도 지원하나요?
A. 모바일/웹 모두 지원해야함

Q. 뉴스피드는 어떤 순서로 표시되어야 하나요? e.g) 최신 포스트, 인기 포스트 등
A. 단순히 최신 포스트로 표시함

Q. 한명의 사용자는 최대 몇명의 친구를 가질 수 있는지?
A. 5000명

Q. 트래픽 규모는?
A. 매일 천만명(10,000,000)

Q. 피드에는 이미지나 비디오도 올라올수 있는지?
A. 올라올 수 있음

# Chapter12 - 채팅 시스템 설계

Q. 어떤 앱을 설계해야 하나요? 1:1 채팅앱인지, 그룹채팅인지?
A. 둘다 지원할 수 있어야함

Q. 모바일 앱인지, 웹앱인지?
A. 둘다임

Q. 트래픽 규모는?
A. DAU 기준 5천만

Q. 그룹채팅의 인원제한은?
A. 최대 100명

Q. 주요 기능으로는 어떤것이 있는지? 예를들면 첨부파일같은..
A. 1:1 채팅, 그룹채팅, 사용자 접속상태 표시, 텍스트 메시지만 주고받을 수 있음

Q. 메시지 길이의 제한이 있는지?
A. 100,000 자가 제한임

Q. 채팅 이력은 얼마나 보관할지?
A. 영구적으로 보관해야함

- 채팅서비스에서는 keepAlive  헤더를 사용하면 효율적이다, 왜냐면, 클라이언트와 서버사이의 연결을 끊지않고 계속 유지할 수 있어서다
- 이는 TCP 접속과정에서 발생하는 핸드셰이크 횟수를 줄일 수 있다
- 수신의 경우에는 폴링, 롱폴링, 웹소켓 등을 고려할 수 있다

- 채팅 시스템이 다루는 데이터는 보통 두 가지이다.
	1. 사용자 프로필, 설정, 친구 목록같은 일반적인 데이터 > 이런 데이터는 안정성을 보장하는 RDS 에 저장한다.
	2. 채팅 시스템의 고유 데이터로 채팅 이력이 해당한다. 이 경우엔 키-값 저장소를 추천한다.
	- 페이스북은 HBase, 디스코드는 카산드라를 사용하고 있다.
	why? 
		- 키-값 저장소는 데이터 접근 지연시간이 낮다.
		- 롱 테일에 해당하는 부분에 접근해도 빠르다.

- 여러 단말 사이의 메시지 동기화?

# Chapter13 - 검색어 자동완성 시스템

Q. 사용자가 입력하는 단어는 자동완성될 검색어의 첫부분인가요 중간부분도 될수있나요?
A. 첫 부분입니다.

Q. 몇개의 자동완성 검색어가 표기되는지?
A. 5개

Q. 5개의 기준은 어떻게 되는지?
A. 빈도에 따라 정해지는 인기순위를 기준으로 한다

Q. 질의는 영어인지?
A. 영어도되고 다국어도 된다

Q. 얼마나 많은 사용자를 지원하는지?
A. DAU 기준 천만명

요구사항
- 빠른 응답속도: 응답속도는 100ms 이내여야 한다
- 연관성: 자동완성 검색어는 입력한 단어와 연관된 것이어야 함
- 정렬: 결과는 인기도 등의 순위모델에 의해 정렬되어야함
- 규모 확장성
- 고가용성

상세설계
- 트라이 자료구조
	- 갱신은 서비스 특성마다 다르겠지만 자주하지 않아도 될지도(주에 한번?)
	- 성능 개선을 위해 검색어 길이를 제한한다
	- 성능 개선을 위해 트라이 자료구조를 캐싱한다
- 검색성능을 위해 브라우저 캐싱을 적극 활용한다

# Chapter14 - 유튜브 설계

개략적 규모 추정
- DAU 500 만
- 한 사용자는 하루 평균 5개의 비디오 시청
- 10% 사용자가 하루 1비디오 업로드
- 비디오 평균 크기는 300mb > 500 만 * 10% * 300mb = 150tb
- CDN 비용
- 비디오는 CDN 에서 재생한다

+ 시스템 설계 면접은 모든것을 밑바닥부터 만드는것과는 관계 없다.
주어진 시간 안에 적절한 기술을 골라 설계를 마치는것이,  그 기술이 각각 어떻게 동작하는지
상세히 설명하는것보다 더 중요하다
예컨대, BLOB 저장소를 쓸것이라면 BLOB 을 어떻게 구현할지 상세한 설명보단 BLOB 을 사용할것이라는 사실만 언급해도 충분하다


널리 사용되는 스트리밍 프로토콜
- MPEG-DASH, MPEG 는 "Moving Picture Experts Group" 의 약어, 
DASH 는 "Dynamic Adaptive Streaming over HTTP" 의 약어
- 애플 HLS, HLS 는 "HTTP Live Streaming" 의 약어

# Chapter15 - 구글 드라이브 설계

파일 업로드 API, 다운로드 API, 파일 갱신 히스토리 제공 API 를 제공한다

파일 업로드 API
- 단순 업로드: 파일의 크기가 작을때 사용
- 이어 올리기(resumable upload): 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 있다고 생각되면 사용

블록 저장소 서버: 클라우드에 데이터 파일을 저장하는 기술, 이 저장소는 파일을 여러개의 블록으로 나누어 저장하며 각 블록에는 고유한 해시값이 할당된다
> 이 해시값은 메타데이터 데이터베이스에 저장된다, 각 블록은 독립적인 객체로 취급된다

최적화 방법
- 델타 동기화: 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화
- 압축: 블록 단위로 압축하면 데이터 크기를 많이 줄일 수 있음