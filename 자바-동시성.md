# Java Concurrency

## Section 01

#### Process * Thread

[Process]

- 프로세스는 프로그램의 실제 실행을 의미, 프로그램 파일을 실행함으로서 
프로그램의 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태
- 프로세스는 운영체재로부터 자원을 할당받은 최소 작업 단위

프로세스
- Stack
	- 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장
	- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- Heap
	- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
	- 메모리의 낮은 주소에서 높은 주소 방향으로 할당

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap 형식으로 할당해준다
- 독립된 메모리 영역을 할당해주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없음, IPC 나 공유메모리 등의 통신기법들을 사용해야 함

[Thread]
- 스레드는 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행단위
- 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다
- 프로세스 내에서 스레드마다 각각의 Stack 만 할당받고, 나머지 Code / Data / Heap 영역은 스레드끼리 공유한다
- 스레드 간 Stack 영역에 접근할 수 없으니 스레드는 독립적인 실행흐름을 가질 수 있어 독립적인 함수 호출이 가능함

[Thread & CPU]
- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위
- 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU 에 할당됨
- 스레드 간 선점이 일어날 때 CPU 의 실행 흐름이 전환되는 컨텍스트 스위칭이 발생


[Process vs Thread]

Process
- 여러 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에 영향을 미치지 않는다. 즉, 프로그램 전체의 안정성을 확보할 수 있다
- 프로세스간 전환(컨텍스트 스위칭) 시 레지스터, 캐시 메모리 초기화 등 무거운 작업으로 인한 비용이 많이 발생한다.
- 프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 크다
- 프로세스 생성시 독립적으로 메모리가 할당되기에 리소스 비용이 크다

Thread
- 여러 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미친다
- 프로세스의 메모리 영역을 공유하기에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용한다
- 스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다
- 스레드 간 공유 메모리 영역의 동시접근으로 인한 동기화 문제가 발생한다
- 하나의 스레드에서 오류가 발생할 경우 프로세스 자체가 종료될 수 있다

<br />

#### Parallel & Concurrent

- 동시성은 특정 순서 없이 겹치는 시간에 시작, 실행 및 완료되는 여러 작업에 관한 것
- 병렬성은 멀티 코어 프로세서에서 동시에 실행되는 동일한 작업의 여러 작업에 관한 것
- 동시성과 병렬성은 비슷하지만 동일하지 않다

[동시성]
- CPU 가 한번에 많은 일을 처리하는 것에 중점을 둠. 즉 많은 작업들을 아주 빠른 시가으로 교체하면서 전체 작업을 처리
- 동시성은 작업의 처리를 빠르게 하기 위한 목적이 아닌 CPU 를 효율적으로 사용하는것에 중점을 둠
	- 스레드가 작업을 처리하다 I/O 블록에 걸린 경우 CPU 는 다른 스레드로 전환해서 작업을 진행
- 동시성은 작업에 대한 처리방식을 어떤식으로 진행할지에 대한 설계적 관점에서 이해해야함
- 동시성은 작업해야 할 수가 CPU 코어 수보다 많을 경우 해당됨, 동시성이 없다면 작업을 순차적으로 진행해야 함

[병렬성]
- 병렬성은 CPU가 동시에 많은 일을 수행하는 것에 중점을 둠. 즉 CPU 가 놀지않고 최대한 바쁘게 동작해야 함
- 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것, 한 개의 코어에서는 절대 병렬성이 구현될 수 없음
- 병렬성은 동시성의 하위 개념으로 작업을 여러 Thread 로 분리하고, 운영체제는 그 Thread 를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것.
- 동시성이 작업 처리 방식에 대한 설계에 관한 것이라면, 병렬성은 하드웨어 계층에서 작업 수행 방식에 관한 것
- 병렬성은 작업해야 할 수가 CPU 코어 수 보다 같거나 적을 경우 가장 효율이 좋음

#### Context Switch

[개요]
- 하나의 CPU 는 동일한 시간에 하나의 작업만 수행할 수 있기에, 여러 프로세스를 동시에 실행할 수 없음
- 하나의 CPU 에서 여러 프로세스를 동시에 처리하기 위해서는 한 프로세스에서 다른 프로세스로 전환해야 하는데
이를 컨텍스트 스위치(context switch) 라고 한다

[Context]
- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register 에는 어떤 값이 저장되있는지에 대한 정보가 필요함
- Context 는 CPU 가 해당 프로세스를 실행하기 위한 프로세스 정보를 의미하며 이 정보들은 운영체제가 관리하는 
PCB 라고 하는 자료구조의 공간에 저장됨

[PCB (Process Control Block)]
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조
- 컨텍스트 스위칭은 CPU 가 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있음

[프로세스 상태]
- 프로세스는 New(생성), Ready(준비), Running(실행), Blocked(대기), Exit(종료) 상태를 가짐
- New: 프로세스를 생성하고 있는 단계로 커널 영역에 PCB 가 만들어진 상태
- Ready: 프로세스가 CPU 를 할당받기 위해 기다리고 있는 상태
- Running: 프로세스가 CPU 를 할당받아 명령어를 실행중인 상태
- Waiting: 프로세스가 I/O 작업 완료 혹은 사건 발생을 기다리는 상태
- Terminated: 프로세스가 종료된 상태

컨텍스트 스위칭이 일어나는 조건
- 실행중인 프로세서에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 프로세스 상태가 running 에서 waiting 상태로 전이된 경우
- RoundRobin 스케줄링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때 해당 프로세스를 중지하고 다른 프로세스를 실행시켜주는 경우

[스레드 컨텍스트 스위칭]

TCB (Thread Control Block)
- Thread 상태정보를 저장하는 자료구조, PC와 Register Set(CPU 정보), 그리고 PCB 를 가리키는 포인터를 가짐
- 스레드가 하나 생성될때마다 PCB 내에서 TCB 가 생성되며 컨텍스트 스위칭이 일어나면 기존의 스레드 TCB 를 저장하고 새로운 스레드의 TCB 를 가져와 실행함

[프로세스 vs 스레드]
- 프로세스는 컨텍스트 스위칭 할 때 메모리 주소 관련 여러 처리(CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정) 등을 하기 때문에 오버헤드가 크다
- 스레드는 프로세스 내 메모리를 공유하기에 메모리 주소관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아 컨텍스트 스위칭이 빠르다
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 어플리케이션 성능이 저하될 수 있음

### CPU Bound & I/O Bound

- 프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행됨
- 프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행함
- 특정 Task 가 완료될때까지 이 작업을 반복함

Burst
- 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것

CPU Burst
- CPU 를 연속적으로 사용하면서 명령어를 실행하는 구간
- 프로세스가 CPU 명령어를 실행하는데 소비하는 시간
- 프로세스의 RUNNING 상태를 처리

I/O Burst
- 연속적으로 I/O 를 실행하는 구간
- 프로세스가 I/O 요청 완료를 기다리는데 걸리는 시간
- 프로세스의 WAITING 상태를 처리함

CPU Bounded Process
- CPU Burst 작업이 많은 프로세스로서 I/O Burst 가 거의 없는 경우에 해당함
- 머신러닝, 블록체인, 동영상 편집 프로그램 등 CPU 연산 위주의 작업을 하는 경우를 의미
- 멀티 코어의 병렬성을 최대한 활용해서 처리 성능을 극대화 하도록 스레드를 운영, 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정

I/O Bounded Process
- I/O Burst 가 빈번히 발생하는 프로세스로서 CPU Burst 가 매우 짧음
- 파일, 키보드, DB, 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우 해당
- CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 idle 상태가 되지 않도록 하고
최적화 된 스레드 수를 운용해서 CPU 의 효율적인 사용을 극대화

### 사용자 모드 vs 커널 모드

운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널이라고 한다

커널
- 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중계자 역할을 함
- CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데에 있다

운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호함
- 응용 프로그램이 하드웨어 자원에 직접 접근해 조작할 수 있다면 자원관리가 되지 않고 프로세스 간 데이터가 훼손되어
컴퓨터 시스템 전체에 오류를 가져오게 됨
- 응용 프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근하도록 해야함

CPU 권한 모드
- CPU 는 명령어를 실행할 때 크게 두가지 권한 모드로 구분해서 실행함. 바로 사용자모드와 커널모드로 구분함
- CPU 는 동작하는 동안 두가지 모드를 번갈아 가면서 수행함

사용자 모드(Mode bit = 1)
- 사용자 응용프로그램의 코드가 실행되는 모드, 메모리의 유저영역만 접근 가능
- 대부분의 응용프로그램은 입출력 장치나 파일로의 접근이 필요하기에 이 때는 유저모드에서 커널모드로 전환이 되어야 함

커널 모드(Mode bit = 0)
- 커널 영역의 코드가 실행되는 모드, 메모리의 유저영역 커널영역 모두 접근 가능
- 하드웨어 자원에 직접 접근할 수 있음

시스템 호출(System Call)
- 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이스
- 결국, 사용자모드에서 하드웨어에 접근하기 위해서는 커널모드로 변경해 접근해야 하는데 이 모드를 전환하는 것이 
System Call 이다
- 사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고
이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다

### 사용자 수준 스레드 & 커널 수준 스레드

- 스레드는 크게 두가지 유형으로 구분됨, 사용자 수준 스레드(User Level Thread), 커널 수준 스레드(Kernel Level Thread)
- 사용자 수준 스레드는 사용자 프로그램에서 관리하고 커널 수준 스레드는 OS 에서 관리함

사용자 수준 스레드(User Level Thread)
- 사용자 영역에서 스레드 라이브러리(Pthreads, Java Thread(JVM)) 에 의해 스레드의 생성과 종료, 
스레드 스케줄링 보관 등 모든것을 관리함
- 커널은 사용자 수준 스레드에 대해 알지 못하며 단일 스레드 프로세스인것처럼 관리함

커널 수준 스레드(Kernel Level Thread)
- 스레드와 관련된 모든 작업을 관리(PCB / TCB 관리)
- 커널 스레드는 OS 스케줄러에 의해 스케줄링 됨
- CPU 는 커널에 의해 생성된 커널 스레드의 실행만 담당함


멀티스레딩 모델
- CPU 는 OS 스케줄러가 예약하는 커널 스레드만 할당받아 실행하기에 사용자 수준 스레드는 커널 수준 스레드와 매핑이 필요
- 사용자 수준 스레드는 세가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있음
	- 다대일, 일대일, 다대다 스레드 매핑

## Section 02


## 스레드 생성

- 자바 스레드는 JVM 에서 User Thread 를 생성할때 시스템 콜을 통해 커널에서 생성된 Kernel Thread 와
1:1 로 매핑되어 최종적으로 커널에서 관리됨
- JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성함
- 자바에서는 Platform Thread 로 정의되어 있음, 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게 됨

### Thread

- void start() : 스레드 시작
- void run() : 스레드 실행 영역
- static void sleep() : 지정된 시간동안 현재 수행중인 스레드 대기
- void join() : 해당 스레드가 종료될때까지 현재 스레드 대기
- void interrupt() : 스레드에 실행 중단 신호 전달
- static boolean interrupt() : 인터럽트 상태 확인
- boolean isInterrupted() : 인터럽트 상태 확인
- void setPriority() : 스레드 우선순위 설정
- boolean isAlive() : 스레드 활성화 여부 반환
- Thread currentThread() : 현재 수행중인 스레드 객체 반환
- int activeCount: 현재 활성화되어있는 스레드 수 반환
- setDaemon : 스레드를 데몬 스레드로 설정
- State getState() : 스레드의 현재 상태 반환

### 자바 스레드

- 자바 스레드는 OS 스케줄러에 의해 실행순서가 결정됨, 스레드 실행 시점을 JVM 에서 제어할 수 없음
- 새로운 스레드는 현재 스레드와 독립적으로 실행, 최대 한번 시작, 스레드가 종료된 이후에는 다시 시작할 수 없음

#### run() 
- 스레드가 실행되면 해당 스레드에 의해 자동으로 호출되는 메소드
- public static void main(String[] args) 가 메인 스레드에 의해 자동으로 호출되는것과 비슷한 원리
- 주의할점: start() 가 아닌 run() 메소드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 
스레드의 실행스택에서 run() 이 실행될 뿐

#### 스레드 스택(Stack)
- 스레드가 생성되면 해당 스레드를 위한 스택이 만들어짐
- 스택은 각 스레드마다 독립적으로 할당되어 작동하기에 스레드 간 접근하거나 공유할 수 없음, 이는 스레드로 부터 안전하다 할 수 있음
- 스택은 각 OS 에 따라 크기가 주어지고 주어진 크기를 넘으면 StackOverFlowError 가 발생함

#### 스레드 종료
- 스레드는 run() 메소드의 코드가 모두 실행되면 자동으로 종료됨
- 스레드는 예외가 발생할 경우 종료되며, 다른 스레드에 영향을 미치지 않음
- 어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우의 종료 기준이 다름



### 스레드 생명주기와 상태

- 자바 스레드는 생성과 실행, 그리고 종료에 따른 상태를 가지고 있음, JVM 에서는 6가지의 스레드 상태가 존재.
(OS 스레드 상태를 의미하지 않음)

- 자바 스레드는 어떤 시점이든 6가지 상태 중 오직 하나의 상태를 가질 수 있음
- 자바 스레드의 현재 상태를 가져오려면 Thread 의 getState() 메서드를 사용해 가져올 수 있음
- Thread 클래스에는 스레드 상태에 대한 ENUM 상수를 제공하는 Thread.State 클래스를 제공

스레드 상태

- 객체 생성(NEW): 스레드 객체가 생성됨, 아직 시작되지 않은 스레드 상태
- 실행 대기(RUNNABLE): 실행중이거나 실행 가능한 스레드 상태
- 일시 정지(WAITING): 대기 중인 스레드 상태, 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(TIMED_WAITING): 대기 시간이 지정된 스레드 상태로서 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(BLOCKED): 모니터 락(Lock) 이 해제될때까지 기다리며 차단된 스레드 상태
- 종료(TERMINATED): 실행이 완료된 스레드 상태

wait() - 다른 스레드에 의해 notify() 받을때까지 대기
join() - 스레드의 실행이 종료되거나 인터럽트가 발생할때까지 대기

## Section 03

### Java Thread Fundamentals


#### sleep()

개요
- 지정한 시간 동안 현재 스레드의 실행을 일시 정지, 대기 상태로 빠졌다가 시간이 지나면 실행대기 상태로 전환
- 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저모드로 전환

API 및 예외
- static sleep(long millis)
	- 지정한 밀리초 동안 스레드를 수면상태로 만듬
- static sleep(long millis, int nanos)
	- 지정한 밀리초에 나노초를 더한 시간동안 스레드를 수면 상태로 만듬
- InterruptedException
	- 스레드가 수면중에 인터럽트 될 경우 InterruptedException 예외가 발생
	- 다른 스레드는 잠자고 있는 스레드에게 인터럽트, 즉 중단 신호를 보낼 수 있음
	- InterruptedException 가 발생하면 스레드는 수면상태에서 깨어나고 실행대기 상태로 전환되어
	실행상태를 기다림

#### sleep(0) 과 sleep(n) 의 의미
- sleep() 메서드는 네이티브 메서드이기에 sleep() 이 실행되면 시스템 콜을 호출하여 유저모드에서 커널모드로 전환됨
- 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다 sleep(1) 을 사용하도록 함

sleep(0)
- 스레드가 커널모드로 전환 후 스케줄러는 현재 스레드와 동일한 우선순위의 스레드가 있을 경우 실행대기상태의 스레드에게
CPU를 할당함으로 컨텍스트 스위칭이 발생함
- 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU 를 할당해
컨텍스트 스위칭 없이 모드 전환만 일어남

sleep(1)
- 스레드가 커널모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기상태로 두고 다른 스레드에게
CPU 를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생함

#### Join
- 한 스레드가 다른 스레드가 종료될 때까지 실행을 중지하고 대기상태에 들어갔다 스레드가 종료되면 실행대기 상태로 전환됨
- 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야하거나 순차적인 흐름을 구성하고자 할때 사용 가능
- Object 클래스의 wait() 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드로 수행, 
내부적으로 wait() & notify() 흐름을 가지고 제어함


Join 의 API 및 예외처리
- void join(): 스레드의 작업이 종료될때까지 대기 상태를 유지
- void join(long millis): 지정한 밀리초 시간동안 스레드의 대기 상태를 유지
- void join(long millis, int nanos): 지정한 밀리초에 나노초를 더한 시간동안 스레드의 대기 상태를 유지
- InterruptedException
	- 스레드가 인터럽트 될 경우 InterruptedException 예외 발생
	- 다른 스레드는 join() 을 수행중인 스레드에게 인터럽트 신호를 보낼 수 있음
	- InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환, 실행상태를 기다림

join() 의 작동방식 정리
- OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join()을 호출한 스레드는 실행대기 상태로 전환되고 CPU가 실행을 재개할때까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러개일 경우 각 스레드의 작업이 종료될때까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다


#### interrupt
- 어떤 주체의 행동이나 실행흐름을 방해한다고 해석할 수 있음
- 자바 스레드에서 interrupt() 는 특정 스레드에게 인터럽트 신호를 알려줌으로서 스레드의 실행을 중단하거나 작업 취소, 강제 종료 등으로 사용할 수 있음

interrupt method
- 스레드에게 인터럽트가 발생했다는 신호를 보내는 메커니즘
- 스레드가 현재 실행흐름을 멈추고 인터럽트 이벤트를 먼저 처리하도록 시그널을 보내는 장치

InterruptedException !!
- interrupt() 메커니즘의 일부이며 대기나 차단 등 블록킹 상태에 있거나 블록킹 상태를 만나는 시점의 스레드에 인터럽트 할때 발생하는 예외
- InterruptedException 이 발생하면 인터럽트 상태는 자동으로 초기화됨, 즉 Thread.interrupted() 한것과 같은 상태로 된다
- 다른 곳에서 인터럽트 상태를 참조하고 있다면 예외 구문에서 대상 스레드에 다시 interrupt() 해야 할 수 있음
- InterruptedException 이 발생하는 케이스는 다음과 같음
	- Thread.sleep(), Thread.join(), Object.wait()
	- Future.get(), BlockingQueue.take()

스레드 우선순위 (Priority)
- 단일 CPU 에서 여러 스레드를 실행하는 것을 스케줄링이라 하며 스레드는 스케줄링에 의해 선점되어 CPU 를 할당받는다
- 자바 런타임은 고정 우선순위 선점형 스케줄링으로 알려진 매우 단순하고 결정적인 스케줄링 알고리즘 지원
(fixed-priority pre-emptive scheduling)
- 이 알고리즘은 실행 대기상태의 스레드 중 상대적인 우선순위에 따라 스레드를 예약함

우선순위 개념
- Java 에서 스레드 우선순위는 1에서 10사이의 정수이며, 정수 값이 높을수록 우선순위가 높다
- 스레드가 생성될 때 우선순위 값이 정해지며 기본 우선순위인 5로 설정됨
- 스케줄러는 우선순위가 높은 스레드를 실행하다가 해당 스레드가 중지, 양보 또는 실행 불가능이 되는 경우에
우선순위가 낮은 스레드를 실행하기 시작함
- 두 스레드의 우선순위가 같을 경우 라운드 로빈(순환할당) 스케줄링 방식에 의해 다음 스레드를 선택함
- 스레드가 반드시 우선순위가 높은 스레드를 실행한다고 보장 할 수 없음, 운영체제마다 다른 정책들이 있을 수 있으며 기아상태를 피하기 위해 스케줄러는 우선순위가 낮은 스레드를 선택할 수 있음

우선순위 유형
- 최소 우선순위: 1, public static int MIN_PRIORITY
- 기본 우선순위: 5, public static int NORM_PRIORITY
- 최대 우선순위: 10, public static int MAX_PRIORITY

우선순위 변경 및 확인
- void setPriority(int newPriority)
	- 스레드에 의해 허용되는 우선 순위 값은 1에서10사이, 이 외에 값을 설정하면 오류가 발생
	- 스레드의 우선순위를 새롭게 변경함
- int getPriority(): 스레드의 우선순위를 반환함


## Section 04

### 스레드 예외처리 - UncaughtExceptionHandler

- 스레드의 run() 메소드는 예외를 던질 수 없음, 예외가 발생할 경우 run 안에서만 예외를 처리해야함
- RuntimeException 타입의 예외가 발생할지라도 스레드 밖에서 예외를 캐치할 수 없고 사라짐
- 스레드가 비정상적으로 종료되었거나 특정 예외를 스레드 외부에서 캐치하기 위해서는 
UncaughtExceptionHandler 인터페이스를 제공함

UncaughtExceptionHandler
- 캐치되지 않는 예외에 대해 Thread 가 갑자기 종료했을때 호출되는 핸들러 인터페이스
- 어떤 원인으로 인해 스레드가 종료되었는지 대상 스레드의 예외를 파악할 수 있음

Thread API
- static void setDefaultUncaughtExceptionHandler
	- 모든 스레드에서 발생하는 UncaughtException 을 처리하는 정적메서드
- void setUncaughtExceptionHandler(UncaughtExceptionHandler e)
	- 대상 스레드에서 발생하는 UncaughtException 을 처리하는 인스턴스 메서드
	- setDefaultUncaughtExceptionHandler 보다 우선순위가 높음!!

### 스레드 중지 - flag variable vs interrupt()

- 자바에서는 무한 반복이나 지속적인 실행 중에 있는 스레드를 중지하거나 종료할 수 있는 API 를 더 이상 사용할 수 없음(suspend(), stop())
- 스레드를 종료하는 방법은 플래그 변수를 사용하거나 interrupt() 를 활용해 구현할 수 있음

Flag Variable
- 플래그 변수의 값이 어떤 조건에 만족할 경우 스레드의 실행을 중지하는 방식
- 플래그 변수는 동시성 문제로 가능한 atomic 변수나 volatile 키워드를 사용하도록 함
(캐시 메모리를 사용하는 이슈가 있을 수 있어서..)

### 사용자 스레드 vs 데몬 스레드

- 자바에서는 크게 두가지 유형의 스레드로 구분함, 사용자 스레드(User Thread) , 데몬 스레드(Daemon Thread)
- 사용자 스레드는 사용자 스레드를 낳고, 데몬 스레드는 데몬 스레드를 낳는다. 즉, 자식 스레드는 부모 스레드의 상태를 상속받는다.
- 자바 어플리케이션이 실행되면 JVM 은 사용자 스레드인 메인스레드와 나머지 데몬 스레드를 동시에 생성하고 시작한다.

메인 스레드(main thread)
- 어플리케이션을 실행할때마다 메인 스레드가 생성되어 실행됨
- 어플리케이션을 실행하는 최초의 스레드이자 어플리케이션 실행을 완료하는 마지막 스레드 역할을 함
- 메인스레드에서 여러 하위 스레드를 추가로 시작할 수 있고, 하위 스레드는 또 여러 하위 스레드를 시작할 수 있음
- 메인 스레드가 사용자 스레드이기에 하위 스레드는 모두 사용자 스레드가 된다

사용자 스레드(User Thread)
- 사용자 스레드는 메인 스레드에서 직접 생성한 스레드를 의미
- 사용자 스레드는 각각 독립적인 생명주기를 가지고 실행하게 되며, 메인 스레드를 포함한 모든 사용자 스레드가 종료하게 되면 어플리케이션이 종료하게 된다
- 사용자 스레드는 foreground 에서 실행되는 높은 우선순위를 가지며, JVM 은 사용자 스레드가 스스로 종료될때까지 어플리케이션을 강제로 종료하지 않고 기다림
- 자바가 제공하는 스레드 풀인 ThreadPoolExecutor 은 사용자 스레드를 생성함

데몬 스레드(Daemon Thread)
- 데몬 스레드는 JVM에서 생성한 스레드이거나 직접 데몬 스레드로 생성한 경우를 말함
- 모든 사용자 스레드가 작업을 완료하면 데몬 스레드의 실행여부에 관계없이 JVM 이 데몬 스레드를 강제로 종료하고 어플리케이션이 종료됨
- 데몬 스레드의 생명주기는 사용자 스레드에 따라 다르며 낮은 우선순위를 가지고 background 에서 실행됨
- 데몬 스레드는 사용자 스레드를 보조 및 지원하는 성격을 가진 스레드로서 보통 사용자 작업을 방해하지 않으면서
백그라운드에서 자동으로 작동되는 기능을 가진 스레드이다
- 자바가 제공하는 스레드 풀인 ForkJoinPool 은 데몬 스레드를 생성한다

### ThreadGroup

- 자바는 스레드 그룹(ThreadGroup) 이라는 객체를 통해 여러 스레드를 그룹화하는 편리한 방법을 제공
- ThreadGroup 은 스레드 집합을 나타내며 스레드 그룹에는 다른 스레드 그룹도 포함될 수 있고, 그룹 내의 모든 스레드는 한번에 종료하거나 중단할 수 있음
- 스레드는 반드시 하나의 스레드 그룹에 포함되어야 하며, 명시적으로 스레드 그룹에 포함시키지 않으면 자신을 생성한 스레드가 속해있는 스레드 그룹에 포함되어 진다
- 일반적으로 사용자가 main 스레드에서 생성하는 모든 스레드는 기본적으로 main 스레드 그룹에 속하게 된다

JVM 의 스레드 그룹 생성과정
- JVM 이 실행되면 최상위 스레드 그룹인 system 스레드 그룹이 생성됨
- JVM 운영에 필요한 데몬 스레드들을 생성해서 system 스레드 그룹에 포함시킴
- system 스레드 그룹의 하위 스레드 그룹인 main 스레드 그룹을 만들고 main 스레드를 그룹에 포함시킴

ThreadGroup API
- ThreadGroup(String name): 스레드 그룹 이름
- ThreadGroup(ThreadGroup parent, String name): 부모 스레드 그룹, 스레드 그룹 이름
- int activeCount(): 현재 그룹 및 하위 그룹에서 실행중인 모든 스레드의 수를 반환
- int activeGroupCount(): 현재 그룹에서 활성화된 모든 하위 그룹의 수를 반환
- int getMaxPriority(): 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위 반환
- void setMaxPriority(int pri): 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위 설정
- void list(): 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보 출력
- String getName(): 스레드 그룹의 이름 반환
- ThreadGroup getParent(): 스레드 그룹의 부모그룹 객체 반환
- boolean parentOf(ThreadGroup group): 현재 그룹이 인자로 전달한 스레드 그룹의 부모인지 여부를 반환
- void interrupt(): 현재 그룹에 포함된 모든 스레드를 인터럽트


### ThreadLocal

- 자바에서 스레드는 오직 자신만이 접근해서 읽고 쓸수있는 로컬 변수 저장소를 제공하는데 이를 ThreadLocal 이라 한다
- 각 스레드는 고유한 ThreadLocal 객체를 속성으로 가지고 있음, ThreadLocal 은 스레드 간 격리되어있음
- 스레드는 ThreadLocal에 저장된 값을 특정한 위치나 시점에 상관없이 어디서나 전역변수처럼 접근해 사용 가능, 변수값을 전달하지 않아도 됨
- 모든 스레드가 공통적으로 처리해야 하는 기능이나 객체를 제어해야 하는 상황에서 스레드마다 다른 값을 적용해야 하는 경우 사용함(인증 주체 보관, 트랜잭션 전파, 로그 추적 등등)

ThreadLocal API
- void set(T value): 스레드 로컬에 값을 저장
- T get(): 스레드로컬에 저장된 값을 가져옴
- void remove(): 스레드 로컬에 저장된 값을 삭제
- withInitial(Supplier<? extends S> supplier): 스레드 로컬을 생성하면서 특정 값으로 초기화함

Thread & ThreadLocal
- 스레드는 ThreadLocal 에 있는 ThreadLocalMap 객체를 자신의 threadLocals 속성에 저장함
- 스레드 생성 시 threadLocals 기본값은 null 이며 ThreadLocal 에 값을 저장할때 ThreadLocalMap 이
생성되고 threadLocals 와 연결됨
- 스레드가 전역적으로 값을 참조할 수 있는 원리는 스레드가 ThreadLocal 의 ThreadLocalMap 에 접근하여
여기에 저장된 값을 바로 꺼내 쓸 수 있기 때문
- ThreadLocalMap 은 항상 새롭게 생성되어 스레드 스택에 저장되기에 근본적으로 스레드간 데이터 공유가 될 수 없고 따라서 동시성 문제가 발생하지 않음

주의사항
- ThreadLocal 에 저장된 값은 스레드마다 독립적으로 저장되기때문에 저장된 데이터를 삭제하지 않아도 메모리를 점유하는것 외에는 문제가 되지 않음
- 그러나 스레드 풀을 사용해서 스레드를 운용한다면 반드시 ThreadLocal 에 저장된 값을 삭제해주어야함
- 스레드풀은 스레드를 재사용하기 때문에 현재 스레드가 이전의 스레드를 재사용한 것이라면, 이전의 스레드에서 삭제하지 않았던 데이터를 참조할 수 있기때문에 문제가 될 수 있음


ThreadLocal 작동원리
- ThreadLocal 은 Thread 와 ThreadLocalMap 을 연결하여 스레드 전용 저장소를 구현하는데 이것이 가능한 이유는 바로 Thread.currentThread() 를 참조할 수 있기 때문.
- Thread.currentThread() 는 현재 실행중인 스레드의 객체를 참조하는것으로 CPU 는 오직 하나의 스레드만 할당받아 처리하기에 ThreadLocal 에서 Thread.currentThread() 를 참조하면 지금 실행중인 스레드의 로컬 변수를 저장하거나 참조할 수 있음
- ThreadLocal 에서 현재 스레드를 참조할 수 있는 방법이 없다면 값을 저장하거나 요청하는 스레드를 식별할 수 없기에 Thread.currentThread() 는 ThreadLocal 의 중요한 데이터 식별 기준이 됨

InheritableThreadLocal
- InheritableThreadLocal 은 ThreadLocal 의 확정 버전으로서 부모 스레드로부터 자식스레드로 값을 전달하고 싶을 경우 InheritableThreadLocal 를 사용할 수 있음
- 값의 상속: 부모스레드가 InheritableThreadLocal 변수에 값을 설정하면, 해당 부모스레드로 부터 생성된 자식스레드들은 부모의 값을 상속받게 됨
- 독립성: 자식 스레드가 상속받은 값을 변경하더라도 부모스레드의 값에는 영향주지 않음

## Section 05 (동기화 개념)

### 싱글 스레드 & 멀티스레드

- 프로세스는 오직 한개의 스레드로 구성하는 싱글스레드, 하나 이상의 스레드로 구성하는 멀티스레드 프로세스로 구분할 수 있음
- 작업 처리에 있어 단일 스레드와 멀티스레드의 선택 기준은 어떤 방식이 자원을 더 효율적으로 사용하고 성능처리에 유리한가 하는 점이다

단일스레드 장점
- 문맥교환이 없다
- 동기화 이슈가 없다
- 자원 비용이 적다
- 프로그래밍 난이도가 낮다

단일스레드 단점
- CPU 멀티코어 활용 못함
- 순차적 실행으로 응답성 및 전체 처리량이 낮다
- I/O 처리 시 CPU 가 낭비됨
- 스레드에 오류가 발생하면 프로그램이 종료됨

멀티스레드 장점
- 동시성으로 사용자의 응답성 향상
- CPU 멀티코어의 병렬성으로 성능 향상
- CPU 낭비 없는 자원의 효율적인 사용
- 한 스레드 오류는 다른 스레드에 영향 없음

멀티스레드 단점
- 빈번한 문맥교환으로 성능이 저하됨
- 스레드 간 동기화 이슈가 발생함
- 스레드 생성 비용이 작지 않음
- 프로그래밍 난이도가 높음


멀티스레딩과 동시성
- CPU 의 동시적 작업 처리는 CPU 코어개수보다 스레드의 개수가 많을때 즉, 멀티스레딩 환경에서 자원을 효율적으로 배분하고 사용하기 위해 설계된 방식
- 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 작업을 같은 메모리 영역에서 동시에 실행할 경우 동시성 문제가 대두됨
- 동시성 문제라 함은 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제
- 동시성 문제는 싱글스레드에서는 절대 발생하지 않으며 멀티스레드를 운용하는 어플리케이션에서 나타나는 현상임

### 동기화와 CPU 관계

동기화란
- 프로세스 혹은 스레드간 공유 영역에 대한 동시접근으로 인해 발생하는 데이터 불일치를 막고 데이터 일관성을 유지하기 위해 순차적으로 공유영역을 수행하도록 보장하는 메카니즘이다

CPU 연산 처리 이해
- 모든 기계의 명령은 원자성을 갖는데, 이는 하나의 기계어 명령어가 실행을 시작할 경우 그 명령의 수행 종료 시 까지는 인터럽트를 받지 않는다
- CPU가 두 개 이상의 명령어를 처리할 경우에는 원자성이 보장되지 않는데, 이는 각 명령을 수행하는 중에 OS가 다른 스케줄링으로 CPU에게 다른 명령을 수행하게 함으로써 현재 수행중인 명령을 인터럽트 즉, 중단하게 된다는 의미이다
- 두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메커니즘이 필요, 즉 한 스레드가 모든 명령을 다 수행될때까지 도중에 중단되지 않도록 해야 한다

### Critical Section (임계영역, 공유 변수 영역)

- 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원에 접근하는 코드 영역을 말한다
- 임계영역은 entry section, critical section, exit section, remainder section 으로 구성됨

Critical Section Problem
- 한 스레드가 critical section 을 실행하고 있을때 다른 스레드가 같은 critical section 을 사용함으로서 발생하는 문제

이 문제의 해결책을 위해서는 3가지 충족 조건이 요구됨
- Mutual Exclusion(상호 배제): 어떤 스레드가 critical section 을 실행중이면 다른 스레드는 동일한 
critical section 을 실행할 수 없다.
- Progress(진행): 임계구역에서 실행중인 스레드가 없고 임계 구역에 진입하려는 스레드가 있을때
어떤 스레드가 들어갈 것인지 적절히 선택해줘야 하며 이 결정은 무한정 미뤄져서는 안된다.
- Bounded Waiting(한정 대기)
	- 다른 스레드가 임계영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 기존 스레드가 임계영역에서 실행할 수 있는 횟수에 제한이 있어야 함
	- Starvation(기아상태) 가 발생하지 않도록 함

동기화 도구들
- 뮤텍스, 세마포어, CAS(Compare and Swap) 과 같은 동기화 도구를 통해 Critical Section Problem 이 발생하지 않도록 할 수 있으며 자바에선 synchronized 키워드를 포함한 여러 동기화 도구들을 제공함

Race Condition(경쟁상태)
- 여러 스레드가 동시에 공유 자원에 액세스하고 조작할때 스레드 간 액세스하는 순서나 시점에 따라 실행결과가 달라질 수 있는데 이를 경쟁 상태라고 한다
- 경쟁상태는 Critical Section Problem 이 해결되지 않은 상태에서 여러 스레드가 동시에 임계영역에 접근해서 
공유 데이터를 조작함으로써 발생하는 상태라 할 수 있음

### 안전한 스레드 구성
- 여러 스레드에서 클래스나 객체에 동시에 접근해서 계속 실행하더라도 지속적인 상황이 보장되는 코드를 
스레드 세이프(Thread-Safe) 즉, 스레드에 안전하다고 한다.
- 기본적으로 클래스 명세에 스레드 안정성을 헤치는 코드나 상태를 가지고 있지 않으면 스레드에 안전하다고 정의할 수 있다
- 스레드에 안전한 코드에는 경쟁상태가 없으며 경쟁 상태는 다수의 스레드가 공유자원에 쓰기작업을 시도할 때 발생하기 때문에 스레드가 실행될 때 어떤 자원을 공유하게 되는지 아는것이 중요하다

스레드에 안전한 구조
- 임계영역을 동기화 한다
	- 동시에 여러개의 스레드가 임계영역을 접근하지 못하도록 락(Lock) 메카니즘을 사용한다
- 동기화 도구를 사용한다
	- 세마포어, CAS, Atomic 변수, 동시성 자료구조 등의 동기화 도구들을 사용해 스레드 안정성을 구현한다
- 스레드의 스택에 한정해서 상태를 관리한다
	- 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- ThreadLocal 을 사용한다
	- 스레드마다 가지고있는 전용 저장소인 ThreadLocal 을 사용해 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- 불변 객체를 사용한다
	- 객체의 상태를 변경할 수 없는 클래스를 사용하거나 클래스를 설계할때 상태를 변경할 수 없도록 만들어 스레드에 안전하도록 한다

스레드 스택 한정
- 지역 변수
	- 기본형 지역변수는 스레드 마다 독립적으로 가지고있는 스택에 저장되기에 스레드간에 공유할 수 없음, 스레드에 안전하다
	- 메서드로 전달되는 기본형 파라미터 변수도 스택에서만 관리되므로 스레드에 안전함

- 지역 객체 참조
	- 지역 변수라 할지라도 객체 참조 변수는 기본형과 다른점이 있는데 객체는 스택에 저장되지 않고 메모리의 힙(heap) 영역에 저장된다는 점이다
	- 지역적으로 생성된 객체가 해당 메서드에서 벗어나지 않고 사용 된다면 스레드는 자신만의 객체를 참조할 수 있게 되어 스레드에 안전하다
	- 지역 참조 변수를 다른 클래스의 메소드에 파라미터로 넘겼을 때, 해당 클래스가 파라미터 변수를 다른 스레드가 접근할 수 있는 멤버변수로 저장했을 경우에는 스레드에 안전하지 않다
	- 문자열 같이 불변 객체는 상태가 변경되지 않기 때문에 스레드에 안전하다



# Section06 (Synchronization Fundamentals - 동기화 기법)

## Mutual Exclusion (상호 배제)
- 뮤텍스(Mutual Exclusion) 또는 상호 배제는 공유 자원에 대한 경쟁상태를 방지하고 동시성 제어를 위한 락 메커니즘이다
- 스레드가 임계영역에서 Mutex 객체의 플래그를 소유하고 있으면(락 획득) 다른 스레드가 액세스 할 수 없으며 해당 임계영역에 액세스하려고 시도하는 모든 스레드는 차단되고 Mutex 객체 플래그가 해제된 경우(락 해제)에만 액세스 할 수 있다
- 이 메커니즘은 Mutex 락을 가진 오직 한개의 스레드만 임계영역에 진입할 수 있으며 락을 획득한 스레드만이 락을 해제할 수 있다

뮤텍스 문제점
- 데드락(DeadLock): 두 개 이상의 스레드가 서로가 가진 락을 기다리면서 상호적으로 블로킹되어 아무 작업도 수행할 수 없는 상태를 의미, 잘못된 뮤텍스 사용으로 인해 데드락이 발생할 수 있음
- 우선 순위 역전(Priority Inversion): 높은 우선순위를 가진 스레드가 낮은 우선순위를 가진 스레드가 보유한 락을 기다리는 동안 블록되는 현상으로 높은 우선순위를 가진 스레드의 작업이 지연될 수 있다, 
우선순위 상속으로 해결할 수 있음
- 오버헤드: 뮤텍스를 사용하면 여러 스레드가 경합하면서 락을 얻기 위해 스레드 스케줄링이 발생함. 
이로 인해 오버헤드가 발생하고 성능이 저하될 수 있음
- 성능 저하: 뮤텍스를 사용하면 락을 얻기 위해 스레드가 대기하게 되고, 스레드의 실행 시간이 블록되면서 성능저하가 발생할 수 있음
- 잘못된 사용: 뮤텍스를 적절하게 사용하지 않거나 잘못된 순서로 락을 해제하는 경우 예기치 않은 동작이 발생할 수 있음

## 세마포어
- 공유자원에 대한 접근을 제어하기 위해 사용되는 신호전달 메커니즘 동기화 도구이다
- 세마포어는 정수형 변수 S 와 P, V 의 두가지 원자적 함수로 구성된 신호전달 메커니즘 동기화 도구이다
- P 는 임계영역을 사용하려는 스레드의 진입 여부를 결정하는 연산으로 Wait 연산이라고도 하고
V 는 대기중인 프로세스를 깨우는 신호(Wake-up)로 Signal 연산이다
- 스레드가 임계영역에 진입하지 못할 경우 자발적으로 대기(BLOCK) 상태로 들어가고 임계영역을 빠져나오는 스레드가
대기상태의 스레드를 실행대기상태로 깨워준다
- 자바에선 java.util.concurren 패키지에 세마포어 구현체를 포함하기에 직접 세마포어를 구현할 필요는 없다

S - 정수형 변수, 공유자원의 개수로서 이 개수만큼 스레드 접근이 허용
P - S가 1 감소, 스레드가 임계구역에 진입하기 전 실행되어 카운트 값을 1 감소
V - S가 1 증가, 스레드가 임계구역에서 빠져나올때 실행되어 카운트 값 1 증가

세마포어 유형
- 카운트 변수 S 가 1인 이진 세마포어와 2 이상의 양수 값을 가진 카운팅 세마포어로 구분할 수 있음

이진 세마포어
- 세마포어를 뮤텍스처럼 락으로 사용하기 위해서는 카운트 변수를 1로 설정하고 한 스레드 안에서 세마포어를 획득하고 해제할 수 있도록 구현한다
- 한 스레드만이 세마포어를 획득할 수 있기에 그 외 다른 모든 스레드가 acquired() 를 호출하게 되면 해당 스레드가 세마포어를 해제하기 전까지 블록된다

카운팅 세마포어
- 카운팅 세마포어는 카운트 변수를 설정해 스레드가 공유할 수 있는 자원의 최대치를 한정해서 운용하는 방식으로 
자원 풀(pool) 이나 컬렉션 크기에 제한을 두고자 할때 유용함 e.g) DB Connection 개수제한, 파일 다운로드 동시실행 제한
- 락을 획득하는 스레드와 해제하는 스레드가 다를 수 있으며 스레드 간 락과 락 해제를 위한 신호를 전달함으로 동기화를 구현한다

세마포어 구조
- Semaphore(int permits): 초기허가할수
- Semaphore(int permits, boolean fair): 초기허가할개수,공정성적용여부
- void acquire(): 세마포어로부터 허가를 얻는다
- void acquire(int permits): 세마포어로부터 지정된 수의 허가를 얻는다
- void acquireUninterruptibly세마포어로부터 허가를 얻는동안 인터럽트에 걸리지 않는다
- void acquireUninterruptibly(int permits): 세마포어로부터 지정된 수의 허가를 얻는동안 인터럽트에 걸리지 않는다
- int availablePermits(): 현재 이용 가능한 허가의 수를 반환한다. 테스트 용으로만 사용해야 한다
- int getQueueLength(): 허가를 얻기 위해 큐에 대기하고 있는 스레드의 추정수를 반환한다. 테스트 용으로만 사용해야 한다
- boolean hasQueuedThreads(): 허가를 얻기 위해 큐에 대기하고 있는 스레드가 존재하는지 여부를 반환한다
- boolean isFair(): 공정한 허가를 구현한 세마포어인지 여부를 반환한다
- void release(): 세마포어의 허가를 해제한다
- void release(int permits): 세마포어의 허가를 지정된 수 만큼 해제한다
- boolean tryAcquire(): 허가를 얻기 위해 시도한다. 허가가 가능하면 허가를 얻게 되고 가능하지 않으면 false 를 반환한다. 인터럽트 및 공정성은 무시된다

뮤텍스와 세마포어
- 동작방식
	- 뮤텍스는 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하도록 보장한다. 즉, 뮤텍스는 상호 배제를 위한 동기화 기법이다.
	- 세마포어는 카운팅 기법으로, 특정 개수의 스레드가 동시에 공유자원에 접근할수 있도록 제어함
	- 이진 세마포어는 뮤텍스와 유사한 역할을 하며 카운팅 세마포어는 양수 값을 가지며, 해당 개수만큼의 스레드가 동시에 접근을 허용한다
- 소유권
	- 뮤텍스는 소유권이 있어서 락을 획득한 스레드만이 락을 해제할 수 있다. 즉, 락을 획득한 스레드가 락을 해제하지 않으면 다른 스레드는 해당 뮤텍스에 접근할 수 없다.
	- 세마포어는 소유권이 없으며, 특정 개수의 스레드가 동시에 접근을 허용하는 카운팅 기법으로 작동한다. 따라서 세마포어를 사용하는 스레드들이 모두 세마포어를 해제할 수 있다.
- 초기값
	- 뮤텍스는 기본적으로 잠겨있는 상태로 시작한다. 한 스레드가 뮤텍스를 획득하여 자원에 접근하면 다른 스레드들은 뮤텍스를 획득하기 위해 블로킹 된다
	- 세마포어는 초기값을 설정할 수 있으며 초기값에 따라서 처음부터 스레드가 자원에 접근할 수 있는지 여부가 결정된다.
- 사용 목적
	- 뮤텍스는 주로 상호배제를 위해 사용되며 하나의 자원에 하나의 스레드만 접근하도록 보장해야 하는 경우에 사용된다
	- 세마포어는 주로 리소스의 한정적인 사용을 제어하는데 사용되며 특정 개수의 스레드만이 동시에 자원에 접근하도록 제한하고자 할때 사용된다

## Monitor
- 자바가 동기화를 지원하기 이해 사용하는 메커니즘은 모니터이며 뮤텍스나 세마포어보다 더 고수준의 동기화이다
- 모든 자바객체는 기본적으로 모니터를 가지며 여러 스레드가 객체의 임계영역에 진입하려고 할때 JVM 은 모니터를 사용하여 스레드 간 동기화를 제공한다
- 자바의 모니터는 상호 배제 및 협력이라는 두 가지 동기화 기능을 제공하며 이를 위해 뮤텍스와 조건변수를 사용한다

상호 배제(Mutual Exclusion)
- 객체가 가지고 있는 모니터 Lock 을 통해 여러 스레드가 동시에 공유 자원에 접근하는것을 막아 데이터의 일관성과 안전성을 보장하는 메커니즘이다
- JVM 은 'synchronized' 키워드를 이용해 뮤텍스 동기화를 암묵적으로 처리해주고 있으며 synchronized 는 메서드나 코드블록에 적용할 수 있다
- synchronized
	- synchronized 블록은  해당 객체의 모니터를 획득할 수 있으며 모니터를 획득한 스레드만이 임계영역에 접근가능하고 그 외 스레드들은 차단되어 대기상태가 된다
	- synchronized 블록을 빠져나오면 모니터 Lock 이 해제되고 대기 중인 다른 스레드 중 하나가 락을 얻고 임계영역에 진입하여 작업을 수행하는 식으로 상호배제가 보장된다

협력(Cooperation)
- 협력은 모니터의 Condition Variable(조건 변수) 를 통해 스레드 간 공동의 목표를 위해 상호협력으로 데이터의 일관성과 안전성을 보장하는 동기화 메커니즘이다
- Condition Variable(조건 변수)
	- 조건변수는 Object 클래스의 메소드인 wait(), notify(), notifyAll() 과 함께 작용하며 특정조건이 만족될때까지 스레드를 대기시키는 기능을 제공
	- 스레드가 특정 조건에 부합하지 않을 때 wait() 메소드를 호출하면 조건변수의 대기 셋(Wait Set) 에 들어가 대기한다
	- 다른 스레드가 특정 조건을 만족해서 notify() 또는 notifyAll() 메소드를 호출하면 해다 조건변수의 대기셋으로부터 스레드들을 깨워 실행시키게 된다
- 조건변수를 통해 스레드 간 대기와 통지를 서로 조절하면서 race condition 과 같은 문제를 방지할 수 잇음
- 모니터 내부에는 여러개의 조건변수를 가질 수 있지만 자바의 모니터에는 오직 한 개의 조건변수만 가질 수 있다

모니터 대기 세트 구조
- 자바의 모니터 내부에는 EntrySet(진입 셋) 과 WaitSet(대기 셋) 이라는 대기 자료구조가 있으며 이들은 멀티스레드 환경에서 스레드들 간의 상호작용을 조절하는 데 사용한다

Entry Set
- EntrySet 은 모니터의 Lock 을 획득하기위해 대기중인 스레드들을 모아놓은 자료구조, 스레드가 Lock 을 사용중인 경우 그 외 다른 스레드는 EntrySet 에 들어가게 된다
- EntrySet 에 있는 스레드들은 Lock 이 반납될때까지 기다리며 락이 반납되면 EntrySet 중 하나의 스레드가 락을 획득하고 임계영역으로 진입하게 된다

WaitSet
- WaitSet 은 모니터의 조건변수와 함께 사용하는 자료구조이며 스레드들이 특정한 조건이 만족할때 까지 대기하고 있는 장소이다
- 스레드는 WaitSet 에 들어가 대기할때 Lock 을 해제한다. 그리고 다른 스레드에 의해 깨어나게 되면 EntrySet 으로 이동해 다시 Lock 을 획득한다

조건 변수 종류
- 조건변수를 통해 상호협력하고있는 두 스레드가 wait() 과 notify() 메서드 실행 후 하나의 모니터를 두고 두 스레드 모두가 소유 가능한 상황이 발생
- 하나는 대기중인 스레드, 하나는 깨우는 스레드로서 어떤 스레드가 모니터를 먼저 소유할것인가에 따라 두 종류의 조건변수로 나눌수 있는데 Signal and wait 과 Signal and Continue 이다

Signal and Wait
- 현재 모니터를 소유하고 있는 스레드가 wait() 을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock 을 해제한 후 Wait Set 에 들어간다
- 깨우는 스레드가 notify() or notifyAll() 명령을 실행하면 Wait Set 에 있는 대기 스레드 중 하나 또는 모든 스레드를 깨우고 깨우는 스레드는 Lock 을 해제하고 대기한다
- 대기에서 깨어난 스레드가 Lock을 획득한 후 모든 작업을 마치고 Lock을 해제하면 깨운 스레드가 Lock을 획득한 후 계속 작업을 진행한다
- 대기 스레드와 깨운 스레드 사이에 다른 스레드가 모니터를 소유할수 없도록 원자적 실행이 보장되어야 한다

Signal and Continue
- 현재 모니터를 소유하고 있는 스레드가 wait() 을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock 을 해제한 후 Wait Set 에 들어간다
- 깨우는 스레드가 notify() or notifyAll() 명령을 실행하면 Wait Set 에 있는 대기 스레드 중 하나 또는 모든 스레드를 깨운다. 이때 일어난 스레드들은 Entry Set 으로 이동한다
- 깨우는 스레드는 Lock 을 계속 유지하면서 모든 작업을 완료하고 Lock 을 해제하면 Entry Set 에 대기하고 있는 모든 스레드가 Lock 을 획득하기 위해 경쟁한다
- 자바에서는 이 조건 변수 형식을 취하고있다

스핀락(SpinLock)
- 스핀락은 뮤텍스나 세마포어와 같은 동기화 기법의 일종으로, 기다리지 않고 스레드가 임계영역을 사용할 수 있을때까지 계속 반복하여 검사하는 동기화 메커니즘이다

Busy Waiting(바쁜 대기)
- 스레드가 어떤 조건이 만족될 때까지 계속해서 반복적으로 검사하는 것을 말한다
- 스레드가 특정 조건을 기다리는 동안 아무런 유용한 작업을 수행하지 않고, 무한 반복 루프를 돌며 CPU 자원을 계속 사용하는 것을 의미
- 스핀락은 이러한 busy waiting 을 사용하는 동기화 기법 중 하나이다

스핀락의 장단점
- 장점
	- 컨텍스트 스위칭 비용 감소: 스핀락은 뮤텍스나 세마포어와 같은 블로킹 기반의 동기화 기법과 달리, 스레드가 공유자원을 얻을때까지 블로킹하지 않고 반복적으로 검사한다. 따라서 스핀락은 컨텍스트 스위칭 비용을 감소시키고, 빠른 공유 자원 접근을 가능하게 한다
	- 대기 시간 감소: 스핀락은 블로킹 대기 없이 바로 공유 자원에 접근하려고 시도하기 때문에, 컨텍스트 스위칭 하는 시간보다 임계영역의 대기 시간이 더 짧을 때 유리하다
- 단점
	- 무한루프로 인한 CPU 리소스 낭비: 스핀락은 공유 자원이 사용 중일 때 무한 루프를 돌면서 계속해서 검사하므로, 다른 스레드가 공유 자원을 해제하지 않는 경우에는 busy waiting으로 인해 CPU 리소스가 낭비될 수 있다
	- 스핀락은 공유자원에 대한 경쟁이 많은 경우, 또는 대기 시간이 긴 경우에는 비효율적이며 스레드들이 공유 자원에 대한 경쟁이 강하게 발생할 경우 스핀락을 사용하면 대기 시간이 더 길어질 수 있다
- 싱글 코어 & 멀티 코어
	- 싱글코어에서 스핀락을 사용하면, 해당 스레드가 무한루프를 돌면서 다른 스레드가 CPU 를 점유할 기회를 주지 않기에 싱글코어 환경에서는 일반적으로 busy waiting 으로 인해 성능이 저하될 수 있으므로 멀티코어 환경에서 사용하는 것이 더 효율적이다

<br />

# Section07 (Java Synchronization)

## synchronized 기본
- 자바는 단일 연산 특성을 보장하기 위해 synchronized 키워드를 제공하고 synchronized 구문을 통해 모니터 영역을 동기화 할 수 있음
- synchronized 는 명시적으로 락을 구현하는것이 아닌 자바에 내장된 락으로서 암묵적인 락 혹은 모니터 락이라고 한다
- synchronized 는 동일한 모니터를 가진 객체에 대해 오직 하나의 스레드만 임계영역에 접근할 수 있도록 보장하며 모니터의 조건 변수를 통해 스레드간 협력으로 동기화를 보장해준다
- synchronized 가 적용된 한 개의 메서드만 호출해도 같은 모니터의 모든 synchronized 메서드까지 락에 잠기게 되어 락이 해제될 때까지는 접근이 안되는 특징을 가지고 있다
- 락은 스레드가 synchronized 블록에 들어가기 전에 자동 확보되며 정상적이든 비정상적이든 예외가 발생해서든 해당 블록을 벗엇날 때 자동으로 해제된다

## synchronized 동기화 유형

### 인스턴스 메소드 동기화 (synchronized method)
- 인스턴스 단위로 모니터가 돚악하여 동일한 인스턴스 안에서 synchronized 가 적용된 곳은 하나의 락을 공유한다
- 인스턴스가 여러개일 경우 인스턴스별로 모니터 객체를 가지므로 스레드는 모니터 별로 락을 획득해서 동기화 영역에 진입하고 빠져나올때 락을 해제할 수 있다

### 정적 메소드 동기화 (static synchronized method)
- 클래스 단위로 모니터가 동작하여 synchronized 가 적용된 곳은 하나의 락을 공유한다
- 인스턴스와는 별개의 모니터를 가지고 임계영역을 동기화하기 때문에 인스턴스 단위로 메서드를 호출할지라도 락은 클래스 단위로 스레드가 공유된다
- 클래스는 메모리에 오직 하나만 존재하므로 하나의 모니터를 공유해서 동기화 하고자 할때 사용할 수 있다

### 인스턴스 메소드 동기화 (synchronized method) + 정적 메소드 동기화 (static synchronized method)
- synchronized method 와 static synchronized method 가 혼용되었을 경우는 각 모니터별로 동기화를 진행한다
- 모니터가 섞여 있기 때문에 동기화 의도한대로 정확하게 동작하는지 주의가 필요하다

### 인스턴스 블록 동기화 (synchronized block)
- 인스턴스 단위로 모니터가 동작하여 synchronized 가 적용된 곳은 하나의 락을 공유한다
- 모든 인스턴스가 모니터를 가지기 때문에 모니터를 여러 인스턴스로 구분해서 동기화를 구성할 수 있다
- 클래스의 인스턴스가 여러개일 경우 인스턴스별로 모니터 객체를 가지며 스레드는 모니터 별로 락을 획득해 synchronized 영역을 진입하고 빠져나올때 락을 해제할 수 있다

### 정적 블록 동기화 (static synchronized block)
- 클래스 단위로 모니터가 동작하며 synchronized 가 적용된 곳은 하나의 락을 공유한다
- 모든 클래스가 모니터를 가지기 때문에 모니터를 여러 클래스로 구분해서 동기화를 구성할 수 있다
- 클래스 모니터가 여러개일 경우 스레드는 모니터별로 락을 획득해서 synchronized 영역을 진입하고 빠져나올때 락을 해제할 수 있다

## synchronized 특성

### 재 진입성
- 모니터 내에서 이미 synchronized 영역에 들어간 스레드가 다시 같은 모니터 영역으로 들어갈 수 있는데, 이를 모니터 재진입 이라고 한다
- 재진입이 가능하다는 것은 락의 획득이 호출 단위가 아닌 스레드 단위로 일어난다는 것을 의미함. 이미 락을 획득한 스레드는 같은 락을 얻기 위해 대기할 필요 없이 synchronized 블록을 만났을때 같은 락을 확보하고 진입함

### 가시성
- synchronized 는 가시성을 지원한다
- 가시성이란 한 스레드가 공유자원을 수정하거나 쓰기 작업을 했을때 다른 스레드가 수정한 내용이 보이는 것을 말한다

### 그 외 특징
- sleep() 을 실행한 스레드는 동기화 영역에서 대기중이더라도 획득한 락을 놓거나 해제하지 않는다
- synchronized 의 동기화 영역에 진입하지 못하고 대기 중인 스레드는 인터럽트 되지 않는다
- synchronized 의 동기화 영역에 진입하지 못하고 대기 중인 스레드가 다시 경쟁해서 모니터를 획득하는것은 순서가 정해져 있지 않다
	- 모니터를 계속 획득하지 못하는 기아 상태의 스레드가 나올 수 있지만 스케줄러가 적절히 조절한다

## 스레드 간 협력 - wait() & notify()

- wait(), notify(), notifyAll() 은 모니터 객체의 조건변수와 함께 사용해 동기화를 구현할 수 있는 동기화 메커니즘
- wait(), notify(), notifyAll() 은 뮤텍스 기법으로 충족되지 않는 동기화 문제를 해결할 수 있는 협력에 의한 동기화 장치
- wait(), notify(), notifyAll() 은 반드시 synchronized 블록 안에서만 사용해야함, 이는 스레드가 모니터 락을 확보한 상태에서 이 API 들이 작동한다는 것을 의미

### wait()
- 스레드를 대기 상태로 전환시키고 모니터 락은 해제되며 다른 스레드가 모니터 락을 획득하여 작업을 수행할 수 있음
- 조건 변수와 함께 상ㅇ되어 특정 조건이 만족할때까지 대기
- 다른 스레드가 동일한 모니터 락을 획득하고 notify() or notifyAll() 을 호출하면 대기중인 스레드가 깨어남
- 스레드는 깨어난 상태에서 바로 실행하는것이 아니라 락을 획득해야 하며 락을 획득한 스레드는 wait() 다음 구문을 수행하게됨
- 인터럽트가 걸리면 InterruptException 예외가 발생하고 인터럽트 된 스레드는 대기에서 깨어나게 됨

### notify(), notifyAll()
- notify() 는 같은 모니터의 조건 변수에서 대기 중인 스레드 중 임의의 하나를 깨우며 notifyAll() 은 스레드 전체를 깨운다
- 어떤 스레드가 깨어날것인지 알 수 없으며 무작위로 선택되기에 notify() 보다 notifyAll() 을 사용하는 것을 선호함

## volatile
- 변수의 가시성과 연산의 순서를 제어하기 위해 사용되는 키워드로서 스레드 간의 데이터 일관성과 가시성을 보장하는 역할을 한다

### CPU 캐시 메모리와 메인 메모리
- 현대 컴퓨터는 대부분 2개 이상의 CPU 가 장착되어있으며 각 코어에는 레지스터와 캐시메모리가 존재함
- CPU 캐시 메모리는 CPU 레지스터와 메인 메모리 사이에서 데이터 흐름을 최적화하고 성능을 향상시키는 고속 메모리이다
- CPU 는 값을 읽어올 때 우선 케시에 해당 값이 있는지 확인하고 없는 경우에만 메인 메모리에서 읽어오는 특성을 가진다

### 가시성
- 멀티스레드 환경에서 공유 변슈의 변경 내용이 한 스레드에서 다른 스레드에게 어떻게 보이는지를 나타내는 개념
- 멀티스레드 프로그래밍에서는 여러 스레드가 동시에 변수를 액세스하고 수정할 수 있기에 모든 스레드에게 변수의 값이 일관되게 보여지도록 가시성이 확보되어야 함

### 가시성 문제
- CPU 캐시에서 작업한 결과가 메인 메모리에 즉시 반영이 되지 않을 경우 결과가 다르게 보여지는 현상을 말함

### volatile 원리
- 캐시 메모리 현상으로 공유변수에 대해 스레드 간 가시성 문제가 발생할 경우 volatile 키워드를 사용하면 가시성 문제를 해결할 수 있다
- 공유 변수에 volatile 키워드를 선언하면 CPU 가 데이터 작업을 할때 메인 메모리에서 공유변수를 읽고 수정된 결과를 메모리에 즉시 반영함으로 가시성 문제를 해결한다

### synchronized
- synchronized 블록을 사용하면 한 시점에 오직 하나의 스레드만이 동기화 영역에 접근할 수 있도록 보장해준다
- synchronized 블록 안에서 참조되는 모든 변수들은 메인 메모리로부터 읽어들여지고 블록을 벗어나면 그 동안 수정된 모든 변수들이 즉시 메인메모리로 반영될 수 있도록 해준다
- synchronized 는 상호배제와 함께 가시성의 문제까지 해결할 수 있는 기능을 포함하고 있다
(synchronized 블록 내에서는 volatile 키워드가 없어도 된다)

volatile 한계점
- volatile 은 스레드 간 공유변수에 대한 가시성을 보장하지만 동시적 상호배제를 보장해 주지 않는다
- volatile 변수를 읽기작업하는 스레드와 쓰기작업하는 스레드가 N:1 의 상황에서는 동시성을 보장하지만 N:N 의 상황에서는 동시성을 보장해 주지 못한다

## Deadlock (교착상태)
- 프로세스나 스레드들이 서로가 소유하고 있는 자원을 기다리며 무한히 대기하고 있는 상태를 말한다
- 교착상태에서는 아무런 진전도 이뤄지지 않아 작업이 진행되지 않는 문제가 발생한다
- DeadLock 은 동일한 환경과 코드에서 발생할 수도 있고 발생하지 않을 수도 있다

### 데드락 발생 조건
데드락은 다음 네가지 조건을 동시에 만족할때 발생함, 한 가지라도 만족하지 않으면 데드락이 발생하지 않는다

1. 상호 배제(Mutual Exclusion)
- 자원은 한번에 하나의 스레드만 사용할 수 있다

2. 점유 대기(Hold and Wait)
- 스레드가 최소한 하나의 자원을 보유한 상태에서 다른 자원을 기다리고 있다

3. 비선점(No Preemption)
- 자원을 할당 받은 스레드가 자원을 스스로 반납하기 전까지 자원을 강제로 빼앗을 수 없다

4. 순환 대기(Circular Wait)
- 각 스레드는 순환적으로 다음 스레드가 요구하는 자원을 가지고 있어 사이클이 형성된다

### 데드락 방지와 원인 추적
- 데드락 방지는 데드락 발생 조건인 네 가지 중에 최소 1가지를 방지함으로서 네 가지를 모두 만족하지 않게 하는 기법이다
- 일단 데드락이 발생하면 어플리케이션에서 데드락을 해소하는것은 어렵고 서버를 재기동하거나 종료하는것 밖에 현실적인 해결책은 없다

1. 한번에 하나 이상의 락을 사용하지 않는다
- 데드락은 스레드가 락을 중첩으로 제어하면서 발생하는 경우가 많기에 가능한 한 스레드가 두 개 이상의 락을 제어하는 상황을 만들지 않도록 하는 것이 좋다
2. 락의 순서를 잘 조정한다
- 불가피하게 여러 개의 락을 사용해야 한다면 락의 점유 순서를 일정한 순서로 정해주도록 함으로써 데드락이 발생할 수 있는 조건 중 하나인 순환 대기를 방지한다
3. 락 타임아웃을 건다
- 락을 요청할 때 일정 시간 이내에 락을 얻지 못하면 다른 작업을 수행하도록 타임아웃을 설정한다
- 락 획득에 타임아웃 오류가 나면 오래 기다리지 않고 다시 제어권이 돌아오기에 데드락 상황이 지나가면 다시 정상으로 돌아온다
4. 메서드는 오픈 호출 형태로 구현한다
- 락을 전혀 확보하지 않은 상태에서 메서드를 호출하는 것을 오픈 호출이라고 하며, 락을 전체 메서드에 적용하지 않고 락이 필요한 임계영역만 보호하도록 한다
- 여러 개의 락을 호출하더라도 동시에 락을 점유하는 것이 아닌 순차적으로 락을 획득하고 해제하는 방식으로 메서드를 호출하도록 한다
5. 스레드 덤프를 활용한다
- 스레드 덤프에는 실행중인 모든 스택 트레이스가 담겨있어 이를 활용해 원인을 추적하고 분석하여 해결방안을 모색할 수 있다

<br />

# Section08 (Java Locks)

## Lock & ReentrantLock
- Lock 구현은 synchronized 구문과 마찬가지로 상호배제와 가시성 기능을 가진 동기화 기법이며 synchronized 보다 더 확장된 락 작업을 제공
- Lock 구현은 tryLock, tryLock(Long, TimeUnit), lockinterruptibly 등을 제공

### void lock
- 락이 다른 스레드에 의해 보유되고 있지 않다면 락을 즉시 획득하고 락의 보유 횟수를 1로 설정한다
- 현재 스레드가 이미 이 락을 보유하고 있다면 보유 횟수가 1 증가하고 메서드는 즉시 반환된다 (락의 재진입 가능)
- 락이 다른 스레드에 의해 보유되어 있다면 현재 스레는 락이 획득될 때까지 대기하며 이후에 락을 성공적으로 획득하면 보유 횟수가 1로 설정된다

### void lockInterruptibly () throws InterruptedException
- 현재 스레드가 인터럽트 되지 않는 한 락을 획득하며 다른 스레드에 의해 보유되지 않는다면 락을 즉시 획득하고 락의 보유 횟수를 1로 설정한다
- 현재 스레드가 이미 이 락을 보유하고 있다면 보유 횟수가 1 증가하고 메서드는 즉시 반환된다 
- 락이 다른 스레드에 의해 보유되어 있다면 락이 현재 스레드에 의해 획득될 때까지 대기한다.
- 현재 스레드가 이 메서드에 진입할 때 인터럽트 상태가 설정되어 있는 경우나 또는 락을 획득하는 도중에 인터럽트가 발생한 경우 Interrupted Exception 발생하며 인터럽트 상태는 초기화 된다
- 락을 정상적으로 또는 재진입으로 획득하는 것보다 인터럽트에 응답하는 것이 우선적으로 처리된다

### boolean tryLock()
- 이 락이 호출 시점에 다른 스레드에 의해 보유되지 않을 때만 락을 획득하고 락의 보유 횟수를 1로 설정하고 true 를 반환한다
- 이 락이 공정성을 가지도록 설정되었더라도 현재 다른 스레드가 락을 기다리는지 여부와 관계없이 락이 사용 가능한 경우 즉시 락을 획득한다 
- 현재 스레드가 이미 이 락을 보유하고 있다면, 보유 횟수가 1 증가하고 true 를 반환한다 
- 락이 다른 스레드에 의해 소유되어 있다면 이 메서드는 즉시 false 값을 반환한다. 그리고 이 메서드는 락을 획득하지 못하더라도 스레드가 대기하거나 차단되지 않는다

### boolean tryLock (long time, TimeUnit unit) throws InterruptedException
- 주어진 대기 시간 내에 다른 스레드에 의해 보유되지 않으면 락을 획득하고 락의 보유 횟수를 1로 설정하고 true 를 반환한다
- 이 락이 공정성을 가지도록 설정 되었다면 락이 사용 가능한 경우에는 다른 스레드가 락을 기다리고 있는지 여부와 상관없이 즉시 락을 획득하지 않는다. 이는 tryLock() 메서드와는 대조적이라 할 수 있다 
- 현재 스레드가 이미 이 락을 보유하고 있다면 보유 횟수가 1 증가하고 메서드는 true 를 반환하고 락이 다른 스레드에 의해 보유되어 있다면 락이 획득될 때까지 대기한다 
- 현재 스레드가 이 메서드를 호출할 때 인터럽트 상태가 설정되어 있거나 락을 획득하는 동안 인터럽트가 발생한 경우 InterruptedException 이 발생 되고 인터럽트 상태가 초기화된다 
- 지정된 대기 시간이 경과하면 값 false 가 반환되며 만약 시간이 0보다 작거나 같으면 메서드는 전혀 대기하지 않는다 - 락의 정상적인 또는 재진입 획득 및 대기 시간 경과 보다 인터럽트에 응답하는 것이 우선적으로 처리된다

## ReadWriteLock & ReentrantWriteLock
- ReadWriteLock 은 읽기 작업과 쓰기 작업을 위해 연관된 두 개의 락(읽기 락, 쓰기 락)을 유지하는 인터페이스
- 일반적으로 락은 데이터를 조작하는 하나의 스레드 임계영역을 보호하는 장치, 데이터를 읽는 작업만 실행되는 영역은 여러 스레드가 접근해도 동시성 문제가 발생하지 않음
- 읽기 작업이 많고 쓰기 작업이 적은 영역을 효율적으로 처리하기 위해 락을 구분해서 운용하는 것이 필요

### 성능 개선
- 읽기 락과 쓰기 락의 조합은 상호 배타적인 락을 사용하는 것보다 데이터에 대한 동시 액세스를 허용하므로 동시성이 높다
- 읽기 작업이 더 빈번한 경우에 효과적

### 메모리 동기화
- 읽기 락 작업은 다른 읽기 락 작업과 상호작용하는것이 아니므로 스레드 간에 동시에 읽기 작업을 하더라도 메모리 가시성에 문제가 없음
- 쓰기 락 작업은 읽기 작업 및 다른 쓰기 작업과의 메모리 동기화를 보장해야함, 즉 스레드가 쓰기 락을 해제하고 다른 스레드가 읽기 락을 얻었을 때 이전 쓰기 작업의 업데이트를 볼 수 있어야 함

### 사용 기준
- 읽기/쓰기 락의 사용은 데이터가 읽히는 빈도와 수정되는 빈도, 읽기 및 쓰기 작업의 지속 시간, 데이터에 대한 경합(동시에 데이터를 읽거나 쓰려는 스레드 수)에 따라 결정된
- 수정은 드물게 일어나고 검색은 빈번히 발생한다면 읽기/쓰기 락의 사용에 적합한 이상적인 후보라 할 수 있지만 업데이트가 빈번해지면 데이터가 대부분 배타적으로 작동한다
- 읽기 작업 시간이 긴 경우 여러 스레드들이 경합없이 모두 읽는 이점이 있으나 너무 짧은 경우 읽기/쓰기 락 구현의 오버헤드가 증가해 효율성이 떨어짐

### ReadLock & WriteLock

### Lock 공정성

불공정성 
- 경쟁 상황에서 읽기 및 쓰기 락에 대한 진입 순서가 정해지지 않음, 하나 이상의 읽기 또는 쓰기 쓰레드를 무기한으로 연기할 수 있으나 일반적으로 공정한 락보다 더 높은 처리량을 가짐
- 락을 획득하려는 시점에 락이 사용중이라면 대기열에 들어가게 되고 락이 해제되었다면 대기열에 대기중인 스레드를 건너뛰고 락을 획득하게 되는 정책
- 공정하게 처리하는 이점보다 불공정하게 처리하는게 성능상 이점이 크다 >> 왜냐면 락을 사용하고자 하는 스레드가 있을때 바로 획득하는 것이 대기중인 스레드를 찾아 락을 획득하도록 처리하는 시간보다 더 빠르기 때문이다

공정성
- 스레드는 도착 순서 정책을 사용한다, 즉 락이 해제될때 가장 오래 기다린 쓰기 쓰레드가 쓰기락을 할당받거나 모든 대기하는 쓰기 스레드보다 더 오래 기다린 읽기 쓰레드 그룹이 있는 경우 해당 그룹이 읽기 락을 할당받는다.
- 공정성 락은 성능은 감수하더라도 기아상태(Starvation)를 방지해야 하는 상황이 필요한 경우 좋은 해결책이 될 수 있다

### Condition
- 조건 변수, 조건 큐로 알려진 객체로서 Lock 과 결합하여 객체 당 여러 개의 Wait Queue 를 가지는 효과를 제공
- Lock 이 synchronized 메서드와 문장의 사용을 대체하는것처럼 Condition 은 Object 모니터 메서드(wait, notify and notifyAll) 의 사용을 대체하며 Lock 에 바인딩된다
- Condition 은 한 스레드에서 다른 스레드로부터 어떤 상태 조건이 참이 될 수 있다는 통지를 받을 때까지 실행을 중단하도록 하는 수단을 제공
- Condition 의 가장 중요한 특성은 락을 원자적으로 해제하고 현재 스레드를 중단하는 것이라면, 이는 Object.wait() 메서드와 동일하게 동작한다


## Java 동기화 도구

- 멀티 스레드 환경에서 스레드 간 경쟁조건을 방지하고 락을 사용하지 않고도 공유변수의 값을 원자적으로 변경하는 방법을 제공

### **CountDownLatch**

- 하나 이상의 스레드가 다른 스레드에서 수행되는 일련의 작업이 완료될때까지 기다릴 수 있게 해주는 동기화 보조 도구
- CountDownLatch 는 주어진 카운트로 초기화되고 await 메서드는 현재 카운트가 countDown 메서드의 호출로 인해 0 이 될때까지 블록되며, 그 이후에 모든 대기중인 스레드가 해제되고 await() 이후 처리가 이루어진다
- CountDownLatch 는 일회성으로 처리된다, 즉 카운트를 재 설정할 수 없다 
(재실행이 필요하다면 CyclicBarrier 를 사용)
- 한 스레드가 여러 번 countDown() 을 호출해도 된다

사용 용도
- 여러 개의 스레드가 병렬로 실행되는 경우 특정 작업이 시작되거나 완료될 때까지 다른 스레드들이 기다리도록 할 수 있다
- 여러 스레드가 초기화 작업을 마칠때까지 기다렸다가 모든 스레드가 완료되면 마무리 작업을 수행할 수 있다

### **CyclicBarrier**

- CyclicBarrier 는 공통된 장벽 지점에 도달할 때까지 일련의 스레드가 서로 기다리도록 하는 동기화 보조 도구
- CyclicBarrier 는 대기중인 스레드가 해제된 후에 재 사용할 수 있기에 순환장벽이라 부른다
- CyclicBarrier 는 옵션으로 Runnable 명령을 지원, 이 명령은 마지막 스레드가 도착한 후에 각 장벽지점마다 한번씩 실행되는 BarrierAction 역할을 수행
- 이 Runnable 은 스레드가 장벽 이후 실행을 계속하기 전에 공유 상태를 업데이트하는데에 유용하다

사용 용도
- 여러 스레드가 병렬로 작업을 수행하다 특정 단계에 도달하거나 모든 스레드가 특정 작업을 완료하고 모이는 지점에서 사용됨, 예를들어 병렬 계산 작업 중 중간 결과를 모두 계산한 후 다음 단계로 넘어가기 위해 스레드들이 모이는 경우 유용함
- 고정된 수의 스레드가 동시에 특정 작업을 수행하고 모든 스레드가 작업을 완료하고 모이는 시점에서 다음 단계를 진행할때 사용됨, 즉 여러 스레드가 협력하여 작업을 나누고 동기화하는데에 적합함