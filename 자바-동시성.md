# Java Concurrency

## Section 01

#### Process * Thread

[Process]

- 프로세스는 프로그램의 실제 실행을 의미, 프로그램 파일을 실행함으로서 
프로그램의 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태
- 프로세스는 운영체재로부터 자원을 할당받은 최소 작업 단위

프로세스
- Stack
	- 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장
	- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- Heap
	- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
	- 메모리의 낮은 주소에서 높은 주소 방향으로 할당

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap 형식으로 할당해준다
- 독립된 메모리 영역을 할당해주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없음, IPC 나 공유메모리 등의 통신기법들을 사용해야 함

[Thread]
- 스레드는 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행단위
- 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다
- 프로세스 내에서 스레드마다 각각의 Stack 만 할당받고, 나머지 Code / Data / Heap 영역은 스레드끼리 공유한다
- 스레드 간 Stack 영역에 접근할 수 없으니 스레드는 독립적인 실행흐름을 가질 수 있어 독립적인 함수 호출이 가능함

[Thread & CPU]
- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위
- 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU 에 할당됨
- 스레드 간 선점이 일어날 때 CPU 의 실행 흐름이 전환되는 컨텍스트 스위칭이 발생


[Process vs Thread]

Process
- 여러 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에 영향을 미치지 않는다. 즉, 프로그램 전체의 안정성을 확보할 수 있다
- 프로세스간 전환(컨텍스트 스위칭) 시 레지스터, 캐시 메모리 초기화 등 무거운 작업으로 인한 비용이 많이 발생한다.
- 프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 크다
- 프로세스 생성시 독립적으로 메모리가 할당되기에 리소스 비용이 크다

Thread
- 여러 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미친다
- 프로세스의 메모리 영역을 공유하기에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용한다
- 스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다
- 스레드 간 공유 메모리 영역의 동시접근으로 인한 동기화 문제가 발생한다
- 하나의 스레드에서 오류가 발생할 경우 프로세스 자체가 종료될 수 있다

<br />

#### Parallel & Concurrent

- 동시성은 특정 순서 없이 겹치는 시간에 시작, 실행 및 완료되는 여러 작업에 관한 것
- 병렬성은 멀티 코어 프로세서에서 동시에 실행되는 동일한 작업의 여러 작업에 관한 것
- 동시성과 병렬성은 비슷하지만 동일하지 않다

[동시성]
- CPU 가 한번에 많은 일을 처리하는 것에 중점을 둠. 즉 많은 작업들을 아주 빠른 시가으로 교체하면서 전체 작업을 처리
- 동시성은 작업의 처리를 빠르게 하기 위한 목적이 아닌 CPU 를 효율적으로 사용하는것에 중점을 둠
	- 스레드가 작업을 처리하다 I/O 블록에 걸린 경우 CPU 는 다른 스레드로 전환해서 작업을 진행
- 동시성은 작업에 대한 처리방식을 어떤식으로 진행할지에 대한 설계적 관점에서 이해해야함
- 동시성은 작업해야 할 수가 CPU 코어 수보다 많을 경우 해당됨, 동시성이 없다면 작업을 순차적으로 진행해야 함

[병렬성]
- 병렬성은 CPU가 동시에 많은 일을 수행하는 것에 중점을 둠. 즉 CPU 가 놀지않고 최대한 바쁘게 동작해야 함
- 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것, 한 개의 코어에서는 절대 병렬성이 구현될 수 없음
- 병렬성은 동시성의 하위 개념으로 작업을 여러 Thread 로 분리하고, 운영체제는 그 Thread 를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것.
- 동시성이 작업 처리 방식에 대한 설계에 관한 것이라면, 병렬성은 하드웨어 계층에서 작업 수행 방식에 관한 것
- 병렬성은 작업해야 할 수가 CPU 코어 수 보다 같거나 적을 경우 가장 효율이 좋음

#### Context Switch

[개요]
- 하나의 CPU 는 동일한 시간에 하나의 작업만 수행할 수 있기에, 여러 프로세스를 동시에 실행할 수 없음
- 하나의 CPU 에서 여러 프로세스를 동시에 처리하기 위해서는 한 프로세스에서 다른 프로세스로 전환해야 하는데
이를 컨텍스트 스위치(context switch) 라고 한다

[Context]
- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register 에는 어떤 값이 저장되있는지에 대한 정보가 필요함
- Context 는 CPU 가 해당 프로세스를 실행하기 위한 프로세스 정보를 의미하며 이 정보들은 운영체제가 관리하는 
PCB 라고 하는 자료구조의 공간에 저장됨

[PCB (Process Control Block)]
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조
- 컨텍스트 스위칭은 CPU 가 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있음

[프로세스 상태]
- 프로세스는 New(생성), Ready(준비), Running(실행), Blocked(대기), Exit(종료) 상태를 가짐
- New: 프로세스를 생성하고 있는 단계로 커널 영역에 PCB 가 만들어진 상태
- Ready: 프로세스가 CPU 를 할당받기 위해 기다리고 있는 상태
- Running: 프로세스가 CPU 를 할당받아 명령어를 실행중인 상태
- Waiting: 프로세스가 I/O 작업 완료 혹은 사건 발생을 기다리는 상태
- Terminated: 프로세스가 종료된 상태

컨텍스트 스위칭이 일어나는 조건
- 실행중인 프로세서에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 프로세스 상태가 running 에서 waiting 상태로 전이된 경우
- RoundRobin 스케줄링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때 해당 프로세스를 중지하고 다른 프로세스를 실행시켜주는 경우

[스레드 컨텍스트 스위칭]

TCB (Thread Control Block)
- Thread 상태정보를 저장하는 자료구조, PC와 Register Set(CPU 정보), 그리고 PCB 를 가리키는 포인터를 가짐
- 스레드가 하나 생성될때마다 PCB 내에서 TCB 가 생성되며 컨텍스트 스위칭이 일어나면 기존의 스레드 TCB 를 저장하고 새로운 스레드의 TCB 를 가져와 실행함

[프로세스 vs 스레드]
- 프로세스는 컨텍스트 스위칭 할 때 메모리 주소 관련 여러 처리(CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정) 등을 하기 때문에 오버헤드가 크다
- 스레드는 프로세스 내 메모리를 공유하기에 메모리 주소관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아 컨텍스트 스위칭이 빠르다
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 어플리케이션 성능이 저하될 수 있음

### CPU Bound & I/O Bound

- 프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행됨
- 프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행함
- 특정 Task 가 완료될때까지 이 작업을 반복함

Burst
- 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것

CPU Burst
- CPU 를 연속적으로 사용하면서 명령어를 실행하는 구간
- 프로세스가 CPU 명령어를 실행하는데 소비하는 시간
- 프로세스의 RUNNING 상태를 처리

I/O Burst
- 연속적으로 I/O 를 실행하는 구간
- 프로세스가 I/O 요청 완료를 기다리는데 걸리는 시간
- 프로세스의 WAITING 상태를 처리함

CPU Bounded Process
- CPU Burst 작업이 많은 프로세스로서 I/O Burst 가 거의 없는 경우에 해당함
- 머신러닝, 블록체인, 동영상 편집 프로그램 등 CPU 연산 위주의 작업을 하는 경우를 의미
- 멀티 코어의 병렬성을 최대한 활용해서 처리 성능을 극대화 하도록 스레드를 운영, 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정

I/O Bounded Process
- I/O Burst 가 빈번히 발생하는 프로세스로서 CPU Burst 가 매우 짧음
- 파일, 키보드, DB, 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우 해당
- CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 idle 상태가 되지 않도록 하고
최적화 된 스레드 수를 운용해서 CPU 의 효율적인 사용을 극대화

### 사용자 모드 vs 커널 모드

운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널이라고 한다

커널
- 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중계자 역할을 함
- CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데에 있다

운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호함
- 응용 프로그램이 하드웨어 자원에 직접 접근해 조작할 수 있다면 자원관리가 되지 않고 프로세스 간 데이터가 훼손되어
컴퓨터 시스템 전체에 오류를 가져오게 됨
- 응용 프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근하도록 해야함

CPU 권한 모드
- CPU 는 명령어를 실행할 때 크게 두가지 권한 모드로 구분해서 실행함. 바로 사용자모드와 커널모드로 구분함
- CPU 는 동작하는 동안 두가지 모드를 번갈아 가면서 수행함

사용자 모드(Mode bit = 1)
- 사용자 응용프로그램의 코드가 실행되는 모드, 메모리의 유저영역만 접근 가능
- 대부분의 응용프로그램은 입출력 장치나 파일로의 접근이 필요하기에 이 때는 유저모드에서 커널모드로 전환이 되어야 함

커널 모드(Mode bit = 0)
- 커널 영역의 코드가 실행되는 모드, 메모리의 유저영역 커널영역 모두 접근 가능
- 하드웨어 자원에 직접 접근할 수 있음

시스템 호출(System Call)
- 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이스
- 결국, 사용자모드에서 하드웨어에 접근하기 위해서는 커널모드로 변경해 접근해야 하는데 이 모드를 전환하는 것이 
System Call 이다
- 사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고
이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다

### 사용자 수준 스레드 & 커널 수준 스레드

- 스레드는 크게 두가지 유형으로 구분됨, 사용자 수준 스레드(User Level Thread), 커널 수준 스레드(Kernel Level Thread)
- 사용자 수준 스레드는 사용자 프로그램에서 관리하고 커널 수준 스레드는 OS 에서 관리함

사용자 수준 스레드(User Level Thread)
- 사용자 영역에서 스레드 라이브러리(Pthreads, Java Thread(JVM)) 에 의해 스레드의 생성과 종료, 
스레드 스케줄링 보관 등 모든것을 관리함
- 커널은 사용자 수준 스레드에 대해 알지 못하며 단일 스레드 프로세스인것처럼 관리함

커널 수준 스레드(Kernel Level Thread)
- 스레드와 관련된 모든 작업을 관리(PCB / TCB 관리)
- 커널 스레드는 OS 스케줄러에 의해 스케줄링 됨
- CPU 는 커널에 의해 생성된 커널 스레드의 실행만 담당함


멀티스레딩 모델
- CPU 는 OS 스케줄러가 예약하는 커널 스레드만 할당받아 실행하기에 사용자 수준 스레드는 커널 수준 스레드와 매핑이 필요
- 사용자 수준 스레드는 세가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있음
	- 다대일, 일대일, 다대다 스레드 매핑

## Section 02


## 스레드 생성

- 자바 스레드는 JVM 에서 User Thread 를 생성할때 시스템 콜을 통해 커널에서 생성된 Kernel Thread 와
1:1 로 매핑되어 최종적으로 커널에서 관리됨
- JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성함
- 자바에서는 Platform Thread 로 정의되어 있음, 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게 됨

### Thread

- void start() : 스레드 시작
- void run() : 스레드 실행 영역
- static void sleep() : 지정된 시간동안 현재 수행중인 스레드 대기
- void join() : 해당 스레드가 종료될때까지 현재 스레드 대기
- void interrupt() : 스레드에 실행 중단 신호 전달
- static boolean interrupt() : 인터럽트 상태 확인
- boolean isInterrupted() : 인터럽트 상태 확인
- void setPriority() : 스레드 우선순위 설정
- boolean isAlive() : 스레드 활성화 여부 반환
- Thread currentThread() : 현재 수행중인 스레드 객체 반환
- int activeCount: 현재 활성화되어있는 스레드 수 반환
- setDaemon : 스레드를 데몬 스레드로 설정
- State getState() : 스레드의 현재 상태 반환

### 자바 스레드

- 자바 스레드는 OS 스케줄러에 의해 실행순서가 결정됨, 스레드 실행 시점을 JVM 에서 제어할 수 없음
- 새로운 스레드는 현재 스레드와 독립적으로 실행, 최대 한번 시작, 스레드가 종료된 이후에는 다시 시작할 수 없음

#### run() 
- 스레드가 실행되면 해당 스레드에 의해 자동으로 호출되는 메소드
- public static void main(String[] args) 가 메인 스레드에 의해 자동으로 호출되는것과 비슷한 원리
- 주의할점: start() 가 아닌 run() 메소드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 
스레드의 실행스택에서 run() 이 실행될 뿐

#### 스레드 스택(Stack)
- 스레드가 생성되면 해당 스레드를 위한 스택이 만들어짐
- 스택은 각 스레드마다 독립적으로 할당되어 작동하기에 스레드 간 접근하거나 공유할 수 없음, 이는 스레드로 부터 안전하다 할 수 있음
- 스택은 각 OS 에 따라 크기가 주어지고 주어진 크기를 넘으면 StackOverFlowError 가 발생함

#### 스레드 종료
- 스레드는 run() 메소드의 코드가 모두 실행되면 자동으로 종료됨
- 스레드는 예외가 발생할 경우 종료되며, 다른 스레드에 영향을 미치지 않음
- 어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우의 종료 기준이 다름



### 스레드 생명주기와 상태

- 자바 스레드는 생성과 실행, 그리고 종료에 따른 상태를 가지고 있음, JVM 에서는 6가지의 스레드 상태가 존재.
(OS 스레드 상태를 의미하지 않음)

- 자바 스레드는 어떤 시점이든 6가지 상태 중 오직 하나의 상태를 가질 수 있음
- 자바 스레드의 현재 상태를 가져오려면 Thread 의 getState() 메서드를 사용해 가져올 수 있음
- Thread 클래스에는 스레드 상태에 대한 ENUM 상수를 제공하는 Thread.State 클래스를 제공

스레드 상태

- 객체 생성(NEW): 스레드 객체가 생성됨, 아직 시작되지 않은 스레드 상태
- 실행 대기(RUNNABLE): 실행중이거나 실행 가능한 스레드 상태
- 일시 정지(WAITING): 대기 중인 스레드 상태, 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(TIMED_WAITING): 대기 시간이 지정된 스레드 상태로서 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(BLOCKED): 모니터 락(Lock) 이 해제될때까지 기다리며 차단된 스레드 상태
- 종료(TERMINATED): 실행이 완료된 스레드 상태

wait() - 다른 스레드에 의해 notify() 받을때까지 대기
join() - 스레드의 실행이 종료되거나 인터럽트가 발생할때까지 대기

## Section 03

### Java Thread Fundamentals


#### sleep()

개요
- 지정한 시간 동안 현재 스레드의 실행을 일시 정지, 대기 상태로 빠졌다가 시간이 지나면 실행대기 상태로 전환
- 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저모드로 전환

API 및 예외
- static sleep(long millis)
	- 지정한 밀리초 동안 스레드를 수면상태로 만듬
- static sleep(long millis, int nanos)
	- 지정한 밀리초에 나노초를 더한 시간동안 스레드를 수면 상태로 만듬
- InterruptedException
	- 스레드가 수면중에 인터럽트 될 경우 InterruptedException 예외가 발생
	- 다른 스레드는 잠자고 있는 스레드에게 인터럽트, 즉 중단 신호를 보낼 수 있음
	- InterruptedException 가 발생하면 스레드는 수면상태에서 깨어나고 실행대기 상태로 전환되어
	실행상태를 기다림

#### sleep(0) 과 sleep(n) 의 의미
- sleep() 메서드는 네이티브 메서드이기에 sleep() 이 실행되면 시스템 콜을 호출하여 유저모드에서 커널모드로 전환됨
- 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다 sleep(1) 을 사용하도록 함

sleep(0)
- 스레드가 커널모드로 전환 후 스케줄러는 현재 스레드와 동일한 우선순위의 스레드가 있을 경우 실행대기상태의 스레드에게
CPU를 할당함으로 컨텍스트 스위칭이 발생함
- 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU 를 할당해
컨텍스트 스위칭 없이 모드 전환만 일어남

sleep(1)
- 스레드가 커널모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기상태로 두고 다른 스레드에게
CPU 를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생함

#### Join
- 한 스레드가 다른 스레드가 종료될 때까지 실행을 중지하고 대기상태에 들어갔다 스레드가 종료되면 실행대기 상태로 전환됨
- 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야하거나 순차적인 흐름을 구성하고자 할때 사용 가능
- Object 클래스의 wait() 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드로 수행, 
내부적으로 wait() & notify() 흐름을 가지고 제어함


Join 의 API 및 예외처리
- void join(): 스레드의 작업이 종료될때까지 대기 상태를 유지
- void join(long millis): 지정한 밀리초 시간동안 스레드의 대기 상태를 유지
- void join(long millis, int nanos): 지정한 밀리초에 나노초를 더한 시간동안 스레드의 대기 상태를 유지
- InterruptedException
	- 스레드가 인터럽트 될 경우 InterruptedException 예외 발생
	- 다른 스레드는 join() 을 수행중인 스레드에게 인터럽트 신호를 보낼 수 있음
	- InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환, 실행상태를 기다림

join() 의 작동방식 정리
- OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join()을 호출한 스레드는 실행대기 상태로 전환되고 CPU가 실행을 재개할때까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러개일 경우 각 스레드의 작업이 종료될때까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다


#### interrupt
- 어떤 주체의 행동이나 실행흐름을 방해한다고 해석할 수 있음
- 자바 스레드에서 interrupt() 는 특정 스레드에게 인터럽트 신호를 알려줌으로서 스레드의 실행을 중단하거나 작업 취소, 강제 종료 등으로 사용할 수 있음

interrupt method
- 스레드에게 인터럽트가 발생했다는 신호를 보내는 메커니즘
- 스레드가 현재 실행흐름을 멈추고 인터럽트 이벤트를 먼저 처리하도록 시그널을 보내는 장치

InterruptedException !!
- interrupt() 메커니즘의 일부이며 대기나 차단 등 블록킹 상태에 있거나 블록킹 상태를 만나는 시점의 스레드에 인터럽트 할때 발생하는 예외
- InterruptedException 이 발생하면 인터럽트 상태는 자동으로 초기화됨, 즉 Thread.interrupted() 한것과 같은 상태로 된다
- 다른 곳에서 인터럽트 상태를 참조하고 있다면 예외 구문에서 대상 스레드에 다시 interrupt() 해야 할 수 있음
- InterruptedException 이 발생하는 케이스는 다음과 같음
	- Thread.sleep(), Thread.join(), Object.wait()
	- Future.get(), BlockingQueue.take()

스레드 우선순위 (Priority)
- 단일 CPU 에서 여러 스레드를 실행하는 것을 스케줄링이라 하며 스레드는 스케줄링에 의해 선점되어 CPU 를 할당받는다
- 자바 런타임은 고정 우선순위 선점형 스케줄링으로 알려진 매우 단순하고 결정적인 스케줄링 알고리즘 지원
(fixed-priority pre-emptive scheduling)
- 이 알고리즘은 실행 대기상태의 스레드 중 상대적인 우선순위에 따라 스레드를 예약함

우선순위 개념
- Java 에서 스레드 우선순위는 1에서 10사이의 정수이며, 정수 값이 높을수록 우선순위가 높다
- 스레드가 생성될 때 우선순위 값이 정해지며 기본 우선순위인 5로 설정됨
- 스케줄러는 우선순위가 높은 스레드를 실행하다가 해당 스레드가 중지, 양보 또는 실행 불가능이 되는 경우에
우선순위가 낮은 스레드를 실행하기 시작함
- 두 스레드의 우선순위가 같을 경우 라운드 로빈(순환할당) 스케줄링 방식에 의해 다음 스레드를 선택함
- 스레드가 반드시 우선순위가 높은 스레드를 실행한다고 보장 할 수 없음, 운영체제마다 다른 정책들이 있을 수 있으며 기아상태를 피하기 위해 스케줄러는 우선순위가 낮은 스레드를 선택할 수 있음

우선순위 유형
- 최소 우선순위: 1, public static int MIN_PRIORITY
- 기본 우선순위: 5, public static int NORM_PRIORITY
- 최대 우선순위: 10, public static int MAX_PRIORITY

우선순위 변경 및 확인
- void setPriority(int newPriority)
	- 스레드에 의해 허용되는 우선 순위 값은 1에서10사이, 이 외에 값을 설정하면 오류가 발생
	- 스레드의 우선순위를 새롭게 변경함
- int getPriority(): 스레드의 우선순위를 반환함


## Section 04

### 스레드 예외처리 - UncaughtExceptionHandler

- 스레드의 run() 메소드는 예외를 던질 수 없음, 예외가 발생할 경우 run 안에서만 예외를 처리해야함
- RuntimeException 타입의 예외가 발생할지라도 스레드 밖에서 예외를 캐치할 수 없고 사라짐
- 스레드가 비정상적으로 종료되었거나 특정 예외를 스레드 외부에서 캐치하기 위해서는 
UncaughtExceptionHandler 인터페이스를 제공함

UncaughtExceptionHandler
- 캐치되지 않는 예외에 대해 Thread 가 갑자기 종료했을때 호출되는 핸들러 인터페이스
- 어떤 원인으로 인해 스레드가 종료되었는지 대상 스레드의 예외를 파악할 수 있음

Thread API
- static void setDefaultUncaughtExceptionHandler
	- 모든 스레드에서 발생하는 UncaughtException 을 처리하는 정적메서드
- void setUncaughtExceptionHandler(UncaughtExceptionHandler e)
	- 대상 스레드에서 발생하는 UncaughtException 을 처리하는 인스턴스 메서드
	- setDefaultUncaughtExceptionHandler 보다 우선순위가 높음!!

### 스레드 중지 - flag variable vs interrupt()

- 자바에서는 무한 반복이나 지속적인 실행 중에 있는 스레드를 중지하거나 종료할 수 있는 API 를 더 이상 사용할 수 없음(suspend(), stop())
- 스레드를 종료하는 방법은 플래그 변수를 사용하거나 interrupt() 를 활용해 구현할 수 있음

Flag Variable
- 플래그 변수의 값이 어떤 조건에 만족할 경우 스레드의 실행을 중지하는 방식
- 플래그 변수는 동시성 문제로 가능한 atomic 변수나 volatile 키워드를 사용하도록 함
(캐시 메모리를 사용하는 이슈가 있을 수 있어서..)

### 사용자 스레드 vs 데몬 스레드

- 자바에서는 크게 두가지 유형의 스레드로 구분함, 사용자 스레드(User Thread) , 데몬 스레드(Daemon Thread)
- 사용자 스레드는 사용자 스레드를 낳고, 데몬 스레드는 데몬 스레드를 낳는다. 즉, 자식 스레드는 부모 스레드의 상태를 상속받는다.
- 자바 어플리케이션이 실행되면 JVM 은 사용자 스레드인 메인스레드와 나머지 데몬 스레드를 동시에 생성하고 시작한다.

메인 스레드(main thread)
- 어플리케이션을 실행할때마다 메인 스레드가 생성되어 실행됨
- 어플리케이션을 실행하는 최초의 스레드이자 어플리케이션 실행을 완료하는 마지막 스레드 역할을 함
- 메인스레드에서 여러 하위 스레드를 추가로 시작할 수 있고, 하위 스레드는 또 여러 하위 스레드를 시작할 수 있음
- 메인 스레드가 사용자 스레드이기에 하위 스레드는 모두 사용자 스레드가 된다

사용자 스레드(User Thread)
- 사용자 스레드는 메인 스레드에서 직접 생성한 스레드를 의미
- 사용자 스레드는 각각 독립적인 생명주기를 가지고 실행하게 되며, 메인 스레드를 포함한 모든 사용자 스레드가 종료하게 되면 어플리케이션이 종료하게 된다
- 사용자 스레드는 foreground 에서 실행되는 높은 우선순위를 가지며, JVM 은 사용자 스레드가 스스로 종료될때까지 어플리케이션을 강제로 종료하지 않고 기다림
- 자바가 제공하는 스레드 풀인 ThreadPoolExecutor 은 사용자 스레드를 생성함

데몬 스레드(Daemon Thread)
- 데몬 스레드는 JVM에서 생성한 스레드이거나 직접 데몬 스레드로 생성한 경우를 말함
- 모든 사용자 스레드가 작업을 완료하면 데몬 스레드의 실행여부에 관계없이 JVM 이 데몬 스레드를 강제로 종료하고 어플리케이션이 종료됨
- 데몬 스레드의 생명주기는 사용자 스레드에 따라 다르며 낮은 우선순위를 가지고 background 에서 실행됨
- 데몬 스레드는 사용자 스레드를 보조 및 지원하는 성격을 가진 스레드로서 보통 사용자 작업을 방해하지 않으면서
백그라운드에서 자동으로 작동되는 기능을 가진 스레드이다
- 자바가 제공하는 스레드 풀인 ForkJoinPool 은 데몬 스레드를 생성한다

### ThreadGroup

- 자바는 스레드 그룹(ThreadGroup) 이라는 객체를 통해 여러 스레드를 그룹화하는 편리한 방법을 제공
- ThreadGroup 은 스레드 집합을 나타내며 스레드 그룹에는 다른 스레드 그룹도 포함될 수 있고, 그룹 내의 모든 스레드는 한번에 종료하거나 중단할 수 있음
- 스레드는 반드시 하나의 스레드 그룹에 포함되어야 하며, 명시적으로 스레드 그룹에 포함시키지 않으면 자신을 생성한 스레드가 속해있는 스레드 그룹에 포함되어 진다
- 일반적으로 사용자가 main 스레드에서 생성하는 모든 스레드는 기본적으로 main 스레드 그룹에 속하게 된다

JVM 의 스레드 그룹 생성과정
- JVM 이 실행되면 최상위 스레드 그룹인 system 스레드 그룹이 생성됨
- JVM 운영에 필요한 데몬 스레드들을 생성해서 system 스레드 그룹에 포함시킴
- system 스레드 그룹의 하위 스레드 그룹인 main 스레드 그룹을 만들고 main 스레드를 그룹에 포함시킴

ThreadGroup API
- ThreadGroup(String name): 스레드 그룹 이름
- ThreadGroup(ThreadGroup parent, String name): 부모 스레드 그룹, 스레드 그룹 이름
- int activeCount(): 현재 그룹 및 하위 그룹에서 실행중인 모든 스레드의 수를 반환
- int activeGroupCount(): 현재 그룹에서 활성화된 모든 하위 그룹의 수를 반환
- int getMaxPriority(): 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위 반환
- void setMaxPriority(int pri): 현재 그룹에 포함된 스레드가 가질 수 있는 최대 우선순위 설정
- void list(): 현재 그룹에 포함된 스레드와 하위 그룹에 대한 정보 출력
- String getName(): 스레드 그룹의 이름 반환
- ThreadGroup getParent(): 스레드 그룹의 부모그룹 객체 반환
- boolean parentOf(ThreadGroup group): 현재 그룹이 인자로 전달한 스레드 그룹의 부모인지 여부를 반환
- void interrupt(): 현재 그룹에 포함된 모든 스레드를 인터럽트


### ThreadLocal

- 자바에서 스레드는 오직 자신만이 접근해서 읽고 쓸수있는 로컬 변수 저장소를 제공하는데 이를 ThreadLocal 이라 한다
- 각 스레드는 고유한 ThreadLocal 객체를 속성으로 가지고 있음, ThreadLocal 은 스레드 간 격리되어있음
- 스레드는 ThreadLocal에 저장된 값을 특정한 위치나 시점에 상관없이 어디서나 전역변수처럼 접근해 사용 가능, 변수값을 전달하지 않아도 됨
- 모든 스레드가 공통적으로 처리해야 하는 기능이나 객체를 제어해야 하는 상황에서 스레드마다 다른 값을 적용해야 하는 경우 사용함(인증 주체 보관, 트랜잭션 전파, 로그 추적 등등)

ThreadLocal API
- void set(T value): 스레드 로컬에 값을 저장
- T get(): 스레드로컬에 저장된 값을 가져옴
- void remove(): 스레드 로컬에 저장된 값을 삭제
- withInitial(Supplier<? extends S> supplier): 스레드 로컬을 생성하면서 특정 값으로 초기화함

Thread & ThreadLocal
- 스레드는 ThreadLocal 에 있는 ThreadLocalMap 객체를 자신의 threadLocals 속성에 저장함
- 스레드 생성 시 threadLocals 기본값은 null 이며 ThreadLocal 에 값을 저장할때 ThreadLocalMap 이
생성되고 threadLocals 와 연결됨
- 스레드가 전역적으로 값을 참조할 수 있는 원리는 스레드가 ThreadLocal 의 ThreadLocalMap 에 접근하여
여기에 저장된 값을 바로 꺼내 쓸 수 있기 때문
- ThreadLocalMap 은 항상 새롭게 생성되어 스레드 스택에 저장되기에 근본적으로 스레드간 데이터 공유가 될 수 없고 따라서 동시성 문제가 발생하지 않음

주의사항
- ThreadLocal 에 저장된 값은 스레드마다 독립적으로 저장되기때문에 저장된 데이터를 삭제하지 않아도 메모리를 점유하는것 외에는 문제가 되지 않음
- 그러나 스레드 풀을 사용해서 스레드를 운용한다면 반드시 ThreadLocal 에 저장된 값을 삭제해주어야함
- 스레드풀은 스레드를 재사용하기 때문에 현재 스레드가 이전의 스레드를 재사용한 것이라면, 이전의 스레드에서 삭제하지 않았던 데이터를 참조할 수 있기때문에 문제가 될 수 있음


ThreadLocal 작동원리
- ThreadLocal 은 Thread 와 ThreadLocalMap 을 연결하여 스레드 전용 저장소를 구현하는데 이것이 가능한 이유는 바로 Thread.currentThread() 를 참조할 수 있기 때문.
- Thread.currentThread() 는 현재 실행중인 스레드의 객체를 참조하는것으로 CPU 는 오직 하나의 스레드만 할당받아 처리하기에 ThreadLocal 에서 Thread.currentThread() 를 참조하면 지금 실행중인 스레드의 로컬 변수를 저장하거나 참조할 수 있음
- ThreadLocal 에서 현재 스레드를 참조할 수 있는 방법이 없다면 값을 저장하거나 요청하는 스레드를 식별할 수 없기에 Thread.currentThread() 는 ThreadLocal 의 중요한 데이터 식별 기준이 됨

InheritableThreadLocal
- InheritableThreadLocal 은 ThreadLocal 의 확정 버전으로서 부모 스레드로부터 자식스레드로 값을 전달하고 싶을 경우 InheritableThreadLocal 를 사용할 수 있음
- 값의 상속: 부모스레드가 InheritableThreadLocal 변수에 값을 설정하면, 해당 부모스레드로 부터 생성된 자식스레드들은 부모의 값을 상속받게 됨
- 독립성: 자식 스레드가 상속받은 값을 변경하더라도 부모스레드의 값에는 영향주지 않음

## Section 05 (동기화 개념)

### 싱글 스레드 & 멀티스레드

- 프로세스는 오직 한개의 스레드로 구성하는 싱글스레드, 하나 이상의 스레드로 구성하는 멀티스레드 프로세스로 구분할 수 있음
- 작업 처리에 있어 단일 스레드와 멀티스레드의 선택 기준은 어떤 방식이 자원을 더 효율적으로 사용하고 성능처리에 유리한가 하는 점이다

단일스레드 장점
- 문맥교환이 없다
- 동기화 이슈가 없다
- 자원 비용이 적다
- 프로그래밍 난이도가 낮다

단일스레드 단점
- CPU 멀티코어 활용 못함
- 순차적 실행으로 응답성 및 전체 처리량이 낮다
- I/O 처리 시 CPU 가 낭비됨
- 스레드에 오류가 발생하면 프로그램이 종료됨

멀티스레드 장점
- 동시성으로 사용자의 응답성 향상
- CPU 멀티코어의 병렬성으로 성능 향상
- CPU 낭비 없는 자원의 효율적인 사용
- 한 스레드 오류는 다른 스레드에 영향 없음

멀티스레드 단점
- 빈번한 문맥교환으로 성능이 저하됨
- 스레드 간 동기화 이슈가 발생함
- 스레드 생성 비용이 작지 않음
- 프로그래밍 난이도가 높음


멀티스레딩과 동시성
- CPU 의 동시적 작업 처리는 CPU 코어개수보다 스레드의 개수가 많을때 즉, 멀티스레딩 환경에서 자원을 효율적으로 배분하고 사용하기 위해 설계된 방식
- 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 작업을 같은 메모리 영역에서 동시에 실행할 경우 동시성 문제가 대두됨
- 동시성 문제라 함은 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제
- 동시성 문제는 싱글스레드에서는 절대 발생하지 않으며 멀티스레드를 운용하는 어플리케이션에서 나타나는 현상임

### 동기화와 CPU 관계

동기화란
- 프로세스 혹은 스레드간 공유 영역에 대한 동시접근으로 인해 발생하는 데이터 불일치를 막고 데이터 일관성을 유지하기 위해 순차적으로 공유영역을 수행하도록 보장하는 메카니즘이다

CPU 연산 처리 이해
- 모든 기계의 명령은 원자성을 갖는데, 이는 하나의 기계어 명령어가 실행을 시작할 경우 그 명령의 수행 종료 시 까지는 인터럽트를 받지 않는다
- CPU가 두 개 이상의 명령어를 처리할 경우에는 원자성이 보장되지 않는데, 이는 각 명령을 수행하는 중에 OS가 다른 스케줄링으로 CPU에게 다른 명령을 수행하게 함으로써 현재 수행중인 명령을 인터럽트 즉, 중단하게 된다는 의미이다
- 두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메커니즘이 필요, 즉 한 스레드가 모든 명령을 다 수행될때까지 도중에 중단되지 않도록 해야 한다

### Critical Section (임계영역, 공유 변수 영역)

- 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원에 접근하는 코드 영역을 말한다
- 임계영역은 entry section, critical section, exit section, remainder section 으로 구성됨

Critical Section Problem
- 한 스레드가 critical section 을 실행하고 있을때 다른 스레드가 같은 critical section 을 사용함으로서 발생하는 문제

이 문제의 해결책을 위해서는 3가지 충족 조건이 요구됨
- Mutual Exclusion(상호 배제): 어떤 스레드가 critical section 을 실행중이면 다른 스레드는 동일한 
critical section 을 실행할 수 없다.
- Progress(진행): 임계구역에서 실행중인 스레드가 없고 임계 구역에 진입하려는 스레드가 있을때
어떤 스레드가 들어갈 것인지 적절히 선택해줘야 하며 이 결정은 무한정 미뤄져서는 안된다.
- Bounded Waiting(한정 대기)
	- 다른 스레드가 임계영역에 들어가도록 요청한 후 해당 요청이 수락되기 전에 기존 스레드가 임계영역에서 실행할 수 있는 횟수에 제한이 있어야 함
	- Starvation(기아상태) 가 발생하지 않도록 함

동기화 도구들
- 뮤텍스, 세마포어, CAS(Compare and Swap) 과 같은 동기화 도구를 통해 Critical Section Problem 이 발생하지 않도록 할 수 있으며 자바에선 synchronized 키워드를 포함한 여러 동기화 도구들을 제공함

Race Condition(경쟁상태)
- 여러 스레드가 동시에 공유 자원에 액세스하고 조작할때 스레드 간 액세스하는 순서나 시점에 따라 실행결과가 달라질 수 있는데 이를 경쟁 상태라고 한다
- 경쟁상태는 Critical Section Problem 이 해결되지 않은 상태에서 여러 스레드가 동시에 임계영역에 접근해서 
공유 데이터를 조작함으로써 발생하는 상태라 할 수 있음

### 안전한 스레드 구성
- 여러 스레드에서 클래스나 객체에 동시에 접근해서 계속 실행하더라도 지속적인 상황이 보장되는 코드를 
스레드 세이프(Thread-Safe) 즉, 스레드에 안전하다고 한다.
- 기본적으로 클래스 명세에 스레드 안정성을 헤치는 코드나 상태를 가지고 있지 않으면 스레드에 안전하다고 정의할 수 있다
- 스레드에 안전한 코드에는 경쟁상태가 없으며 경쟁 상태는 다수의 스레드가 공유자원에 쓰기작업을 시도할 때 발생하기 때문에 스레드가 실행될 때 어떤 자원을 공유하게 되는지 아는것이 중요하다

스레드에 안전한 구조
- 임계영역을 동기화 한다
	- 동시에 여러개의 스레드가 임계영역을 접근하지 못하도록 락(Lock) 메카니즘을 사용한다
- 동기화 도구를 사용한다
	- 세마포어, CAS, Atomic 변수, 동시성 자료구조 등의 동기화 도구들을 사용해 스레드 안정성을 구현한다
- 스레드의 스택에 한정해서 상태를 관리한다
	- 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- ThreadLocal 을 사용한다
	- 스레드마다 가지고있는 전용 저장소인 ThreadLocal 을 사용해 상태를 관리함으로서 다른 스레드와 상태를 공유할 수 없도록 한다
- 불변 객체를 사용한다
	- 객체의 상태를 변경할 수 없는 클래스를 사용하거나 클래스를 설계할때 상태를 변경할 수 없도록 만들어 스레드에 안전하도록 한다

스레드 스택 한정
- 지역 변수
	- 기본형 지역변수는 스레드 마다 독립적으로 가지고있는 스택에 저장되기에 스레드간에 공유할 수 없음, 스레드에 안전하다
	- 메서드로 전달되는 기본형 파라미터 변수도 스택에서만 관리되므로 스레드에 안전함

- 지역 객체 참조
	- 지역 변수라 할지라도 객체 참조 변수는 기본형과 다른점이 있는데 객체는 스택에 저장되지 않고 메모리의 힙(heap) 영역에 저장된다는 점이다
	- 지역적으로 생성된 객체가 해당 메서드에서 벗어나지 않고 사용 된다면 스레드는 자신만의 객체를 참조할 수 있게 되어 스레드에 안전하다
	- 지역 참조 변수를 다른 클래스의 메소드에 파라미터로 넘겼을 때, 해당 클래스가 파라미터 변수를 다른 스레드가 접근할 수 있는 멤버변수로 저장했을 경우에는 스레드에 안전하지 않다
	- 문자열 같이 불변 객체는 상태가 변경되지 않기 때문에 스레드에 안전하다



# Section06 (Synchronization Fundamentals - 동기화 기법)

## Mutual Exclusion (상호 배제)
- 뮤텍스(Mutual Exclusion) 또는 상호 배제는 공유 자원에 대한 경쟁상태를 방지하고 동시성 제어를 위한 락 메커니즘이다
- 스레드가 임계영역에서 Mutex 객체의 플래그를 소유하고 있으면(락 획득) 다른 스레드가 액세스 할 수 없으며 해당 임계영역에 액세스하려고 시도하는 모든 스레드는 차단되고 Mutex 객체 플래그가 해제된 경우(락 해제)에만 액세스 할 수 있다
- 이 메커니즘은 Mutex 락을 가진 오직 한개의 스레드만 임계영역에 진입할 수 있으며 락을 획득한 스레드만이 락을 해제할 수 있다

뮤텍스 문제점
- 데드락(DeadLock): 두 개 이상의 스레드가 서로가 가진 락을 기다리면서 상호적으로 블로킹되어 아무 작업도 수행할 수 없는 상태를 의미, 잘못된 뮤텍스 사용으로 인해 데드락이 발생할 수 있음
- 우선 순위 역전(Priority Inversion): 높은 우선순위를 가진 스레드가 낮은 우선순위를 가진 스레드가 보유한 락을 기다리는 동안 블록되는 현상으로 높은 우선순위를 가진 스레드의 작업이 지연될 수 있다, 
우선순위 상속으로 해결할 수 있음
- 오버헤드: 뮤텍스를 사용하면 여러 스레드가 경합하면서 락을 얻기 위해 스레드 스케줄링이 발생함. 
이로 인해 오버헤드가 발생하고 성능이 저하될 수 있음
- 성능 저하: 뮤텍스를 사용하면 락을 얻기 위해 스레드가 대기하게 되고, 스레드의 실행 시간이 블록되면서 성능저하가 발생할 수 있음
- 잘못된 사용: 뮤텍스를 적절하게 사용하지 않거나 잘못된 순서로 락을 해제하는 경우 예기치 않은 동작이 발생할 수 있음

## 세마포어
- 공유자원에 대한 접근을 제어하기 위해 사용되는 신호전달 메커니즘 동기화 도구이다
- 세마포어는 정수형 변수 S 와 P, V 의 두가지 원자적 함수로 구성된 신호전달 메커니즘 동기화 도구이다
- P 는 임계영역을 사용하려는 스레드의 진입 여부를 결정하는 연산으로 Wait 연산이라고도 하고
V 는 대기중인 프로세스를 깨우는 신호(Wake-up)로 Signal 연산이다
- 스레드가 임계영역에 진입하지 못할 경우 자발적으로 대기(BLOCK) 상태로 들어가고 임계영역을 빠져나오는 스레드가
대기상태의 스레드를 실행대기상태로 깨워준다
- 자바에선 java.util.concurren 패키지에 세마포어 구현체를 포함하기에 직접 세마포어를 구현할 필요는 없다

S - 정수형 변수, 공유자원의 개수로서 이 개수만큼 스레드 접근이 허용
P - S가 1 감소, 스레드가 임계구역에 진입하기 전 실행되어 카운트 값을 1 감소
V - S가 1 증가, 스레드가 임계구역에서 빠져나올때 실행되어 카운트 값 1 증가

세마포어 유형
- 카운트 변수 S 가 1인 이진 세마포어와 2 이상의 양수 값을 가진 카운팅 세마포어로 구분할 수 있음

이진 세마포어
- 세마포어를 뮤텍스처럼 락으로 사용하기 위해서는 카운트 변수를 1로 설정하고 한 스레드 안에서 세마포어를 획득하고 해제할 수 있도록 구현한다
- 한 스레드만이 세마포어를 획득할 수 있기에 그 외 다른 모든 스레드가 acquired() 를 호출하게 되면 해당 스레드가 세마포어를 해제하기 전까지 블록된다

카운팅 세마포어
- 카운팅 세마포어는 카운트 변수를 설정해 스레드가 공유할 수 있는 자원의 최대치를 한정해서 운용하는 방식으로 
자원 풀(pool) 이나 컬렉션 크기에 제한을 두고자 할때 유용함 e.g) DB Connection 개수제한, 파일 다운로드 동시실행 제한
- 락을 획득하는 스레드와 해제하는 스레드가 다를 수 있으며 스레드 간 락과 락 해제를 위한 신호를 전달함으로 동기화를 구현한다

세마포어 구조
- Semaphore(int permits): 초기허가할수
- Semaphore(int permits, boolean fair): 초기허가할개수,공정성적용여부
- void acquire(): 세마포어로부터 허가를 얻는다
- void acquire(int permits): 세마포어로부터 지정된 수의 허가를 얻는다
- void acquireUninterruptibly세마포어로부터 허가를 얻는동안 인터럽트에 걸리지 않는다
- void acquireUninterruptibly(int permits): 세마포어로부터 지정된 수의 허가를 얻는동안 인터럽트에 걸리지 않는다
- int availablePermits(): 현재 이용 가능한 허가의 수를 반환한다. 테스트 용으로만 사용해야 한다
- int getQueueLength(): 허가를 얻기 위해 큐에 대기하고 있는 스레드의 추정수를 반환한다. 테스트 용으로만 사용해야 한다
- boolean hasQueuedThreads(): 허가를 얻기 위해 큐에 대기하고 있는 스레드가 존재하는지 여부를 반환한다
- boolean isFair(): 공정한 허가를 구현한 세마포어인지 여부를 반환한다
- void release(): 세마포어의 허가를 해제한다
- void release(int permits): 세마포어의 허가를 지정된 수 만큼 해제한다
- boolean tryAcquire(): 허가를 얻기 위해 시도한다. 허가가 가능하면 허가를 얻게 되고 가능하지 않으면 false 를 반환한다. 인터럽트 및 공정성은 무시된다

뮤텍스와 세마포어
- 동작방식
	- 뮤텍스는 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하도록 보장한다. 즉, 뮤텍스는 상호 배제를 위한 동기화 기법이다.
	- 세마포어는 카운팅 기법으로, 특정 개수의 스레드가 동시에 공유자원에 접근할수 있도록 제어함
	- 이진 세마포어는 뮤텍스와 유사한 역할을 하며 카운팅 세마포어는 양수 값을 가지며, 해당 개수만큼의 스레드가 동시에 접근을 허용한다
- 소유권
	- 뮤텍스는 소유권이 있어서 락을 획득한 스레드만이 락을 해제할 수 있다. 즉, 락을 획득한 스레드가 락을 해제하지 않으면 다른 스레드는 해당 뮤텍스에 접근할 수 없다.
	- 세마포어는 소유권이 없으며, 특정 개수의 스레드가 동시에 접근을 허용하는 카운팅 기법으로 작동한다. 따라서 세마포어를 사용하는 스레드들이 모두 세마포어를 해제할 수 있다.
- 초기값
	- 뮤텍스는 기본적으로 잠겨있는 상태로 시작한다. 한 스레드가 뮤텍스를 획득하여 자원에 접근하면 다른 스레드들은 뮤텍스를 획득하기 위해 블로킹 된다
	- 세마포어는 초기값을 설정할 수 있으며 초기값에 따라서 처음부터 스레드가 자원에 접근할 수 있는지 여부가 결정된다.
- 사용 목적
	- 뮤텍스는 주로 상호배제를 위해 사용되며 하나의 자원에 하나의 스레드만 접근하도록 보장해야 하는 경우에 사용된다
	- 세마포어는 주로 리소스의 한정적인 사용을 제어하는데 사용되며 특정 개수의 스레드만이 동시에 자원에 접근하도록 제한하고자 할때 사용된다

## Monitor
- 자바가 동기화를 지원하기 이해 사용하는 메커니즘은 모니터이며 뮤텍스나 세마포어보다 더 고수준의 동기화이다
- 모든 자바객체는 기본적으로 모니터를 가지며 여러 스레드가 객체의 임계영역에 진입하려고 할때 JVM 은 모니터를 사용하여 스레드 간 동기화를 제공한다
- 자바의 모니터는 상호 배제 및 협력이라는 두 가지 동기화 기능을 제공하며 이를 위해 뮤텍스와 조건변수를 사용한다

상호 배제(Mutual Exclusion)
- 객체가 가지고 있는 모니터 Lock 을 통해 여러 스레드가 동시에 공유 자원에 접근하는것을 막아 데이터의 일관성과 안전성을 보장하는 메커니즘이다
- JVM 은 'synchronized' 키워드를 이용해 뮤텍스 동기화를 암묵적으로 처리해주고 있으며 synchronized 는 메서드나 코드블록에 적용할 수 있다
- synchronized
	- synchronized 블록은  해당 객체의 모니터를 획득할 수 있으며 모니터를 획득한 스레드만이 임계영역에 접근가능하고 그 외 스레드들은 차단되어 대기상태가 된다
	- synchronized 블록을 빠져나오면 모니터 Lock 이 해제되고 대기 중인 다른 스레드 중 하나가 락을 얻고 임계영역에 진입하여 작업을 수행하는 식으로 상호배제가 보장된다

협력(Cooperation)
- 협력은 모니터의 Condition Variable(조건 변수) 를 통해 스레드 간 공동의 목표를 위해 상호협력으로 데이터의 일관성과 안전성을 보장하는 동기화 메커니즘이다
- Condition Variable(조건 변수)
	- 조건변수는 Object 클래스의 메소드인 wait(), notify(), notifyAll() 과 함께 작용하며 특정조건이 만족될때까지 스레드를 대기시키는 기능을 제공
	- 스레드가 특정 조건에 부합하지 않을 때 wait() 메소드를 호출하면 조건변수의 대기 셋(Wait Set) 에 들어가 대기한다
	- 다른 스레드가 특정 조건을 만족해서 notify() 또는 notifyAll() 메소드를 호출하면 해다 조건변수의 대기셋으로부터 스레드들을 깨워 실행시키게 된다
- 조건변수를 통해 스레드 간 대기와 통지를 서로 조절하면서 race condition 과 같은 문제를 방지할 수 잇음
- 모니터 내부에는 여러개의 조건변수를 가질 수 있지만 자바의 모니터에는 오직 한 개의 조건변수만 가질 수 있다

모니터 대기 세트 구조
- 자바의 모니터 내부에는 EntrySet(진입 셋) 과 WaitSet(대기 셋) 이라는 대기 자료구조가 있으며 이들은 멀티스레드 환경에서 스레드들 간의 상호작용을 조절하는 데 사용한다

Entry Set
- EntrySet 은 모니터의 Lock 을 획득하기위해 대기중인 스레드들을 모아놓은 자료구조, 스레드가 Lock 을 사용중인 경우 그 외 다른 스레드는 EntrySet 에 들어가게 된다
- EntrySet 에 있는 스레드들은 Lock 이 반납될때까지 기다리며 락이 반납되면 EntrySet 중 하나의 스레드가 락을 획득하고 임계영역으로 진입하게 된다

WaitSet
- WaitSet 은 모니터의 조건변수와 함께 사용하는 자료구조이며 스레드들이 특정한 조건이 만족할때 까지 대기하고 있는 장소이다
- 스레드는 WaitSet 에 들어가 대기할때 Lock 을 해제한다. 그리고 다른 스레드에 의해 깨어나게 되면 EntrySet 으로 이동해 다시 Lock 을 획득한다

조건 변수 종류
- 조건변수를 통해 상호협력하고있는 두 스레드가 wait() 과 notify() 메서드 실행 후 하나의 모니터를 두고 두 스레드 모두가 소유 가능한 상황이 발생
- 하나는 대기중인 스레드, 하나는 깨우는 스레드로서 어떤 스레드가 모니터를 먼저 소유할것인가에 따라 두 종류의 조건변수로 나눌수 있는데 Signal and wait 과 Signal and Continue 이다

Signal and Wait
- 현재 모니터를 소유하고 있는 스레드가 wait() 을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock 을 해제한 후 Wait Set 에 들어간다
- 깨우는 스레드가 notify() or notifyAll() 명령을 실행하면 Wait Set 에 있는 대기 스레드 중 하나 또는 모든 스레드를 깨우고 깨우는 스레드는 Lock 을 해제하고 대기한다
- 대기에서 깨어난 스레드가 Lock을 획득한 후 모든 작업을 마치고 Lock을 해제하면 깨운 스레드가 Lock을 획득한 후 계속 작업을 진행한다
- 대기 스레드와 깨운 스레드 사이에 다른 스레드가 모니터를 소유할수 없도록 원자적 실행이 보장되어야 한다

Signal and Continue
- 현재 모니터를 소유하고 있는 스레드가 wait() 을 실행하면 모니터 내부에서 자신을 일시 중단하고 Lock 을 해제한 후 Wait Set 에 들어간다
- 깨우는 스레드가 notify() or notifyAll() 명령을 실행하면 Wait Set 에 있는 대기 스레드 중 하나 또는 모든 스레드를 깨운다. 이때 일어난 스레드들은 Entry Set 으로 이동한다
- 깨우는 스레드는 Lock 을 계속 유지하면서 모든 작업을 완료하고 Lock 을 해제하면 Entry Set 에 대기하고 있는 모든 스레드가 Lock 을 획득하기 위해 경쟁한다
- 자바에서는 이 조건 변수 형식을 취하고있다

스핀락(SpinLock)
- 스핀락은 뮤텍스나 세마포어와 같은 동기화 기법의 일종으로, 기다리지 않고 스레드가 임계영역을 사용할 수 있을때까지 계속 반복하여 검사하는 동기화 메커니즘이다

Busy Waiting(바쁜 대기)
- 스레드가 어떤 조건이 만족될 때까지 계속해서 반복적으로 검사하는 것을 말한다
- 스레드가 특정 조건을 기다리는 동안 아무런 유용한 작업을 수행하지 않고, 무한 반복 루프를 돌며 CPU 자원을 계속 사용하는 것을 의미
- 스핀락은 이러한 busy waiting 을 사용하는 동기화 기법 중 하나이다

스핀락의 장단점
- 장점
	- 컨텍스트 스위칭 비용 감소: 스핀락은 뮤텍스나 세마포어와 같은 블로킹 기반의 동기화 기법과 달리, 스레드가 공유자원을 얻을때까지 블로킹하지 않고 반복적으로 검사한다. 따라서 스핀락은 컨텍스트 스위칭 비용을 감소시키고, 빠른 공유 자원 접근을 가능하게 한다
	- 대기 시간 감소: 스핀락은 블로킹 대기 없이 바로 공유 자원에 접근하려고 시도하기 때문에, 컨텍스트 스위칭 하는 시간보다 임계영역의 대기 시간이 더 짧을 때 유리하다
- 단점
	- 무한루프로 인한 CPU 리소스 낭비: 스핀락은 공유 자원이 사용 중일 때 무한 루프를 돌면서 계속해서 검사하므로, 다른 스레드가 공유 자원을 해제하지 않는 경우에는 busy waiting으로 인해 CPU 리소스가 낭비될 수 있다
	- 스핀락은 공유자원에 대한 경쟁이 많은 경우, 또는 대기 시간이 긴 경우에는 비효율적이며 스레드들이 공유 자원에 대한 경쟁이 강하게 발생할 경우 스핀락을 사용하면 대기 시간이 더 길어질 수 있다
- 싱글 코어 & 멀티 코어
	- 싱글코어에서 스핀락을 사용하면, 해당 스레드가 무한루프를 돌면서 다른 스레드가 CPU 를 점유할 기회를 주지 않기에 싱글코어 환경에서는 일반적으로 busy waiting 으로 인해 성능이 저하될 수 있으므로 멀티코어 환경에서 사용하는 것이 더 효율적이다

# Section07

