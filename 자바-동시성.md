# Java Concurrency

## Section 01

#### Process * Thread

[Process]

- 프로세스는 프로그램의 실제 실행을 의미, 프로그램 파일을 실행함으로서 
프로그램의 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태
- 프로세스는 운영체재로부터 자원을 할당받은 최소 작업 단위

프로세스
- Stack
	- 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장
	- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- Heap
	- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
	- 메모리의 낮은 주소에서 높은 주소 방향으로 할당

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap 형식으로 할당해준다
- 독립된 메모리 영역을 할당해주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없음, IPC 나 공유메모리 등의 통신기법들을 사용해야 함

[Thread]
- 스레드는 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행단위
- 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다
- 프로세스 내에서 스레드마다 각각의 Stack 만 할당받고, 나머지 Code / Data / Heap 영역은 스레드끼리 공유한다
- 스레드 간 Stack 영역에 접근할 수 없으니 스레드는 독립적인 실행흐름을 가질 수 있어 독립적인 함수 호출이 가능함

[Thread & CPU]
- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위
- 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU 에 할당됨
- 스레드 간 선점이 일어날 때 CPU 의 실행 흐름이 전환되는 컨텍스트 스위칭이 발생


[Process vs Thread]

Process
- 여러 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에 영향을 미치지 않는다. 즉, 프로그램 전체의 안정성을 확보할 수 있다
- 프로세스간 전환(컨텍스트 스위칭) 시 레지스터, 캐시 메모리 초기화 등 무거운 작업으로 인한 비용이 많이 발생한다.
- 프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 크다
- 프로세스 생성시 독립적으로 메모리가 할당되기에 리소스 비용이 크다

Thread
- 여러 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미친다
- 프로세스의 메모리 영역을 공유하기에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용한다
- 스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다
- 스레드 간 공유 메모리 영역의 동시접근으로 인한 동기화 문제가 발생한다
- 하나의 스레드에서 오류가 발생할 경우 프로세스 자체가 종료될 수 있다

<br />

## Section 02

## Section 03

## Section 04

## Section 05