# Java Concurrency

## Section 01

#### Process * Thread

[Process]

- 프로세스는 프로그램의 실제 실행을 의미, 프로그램 파일을 실행함으로서 
프로그램의 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태
- 프로세스는 운영체재로부터 자원을 할당받은 최소 작업 단위

프로세스
- Stack
	- 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장
	- 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- Heap
	- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
	- 메모리의 낮은 주소에서 높은 주소 방향으로 할당

- 운영체제는 프로세스마다 각각 독립된 메모리 영역을 Code/Data/Stack/Heap 형식으로 할당해준다
- 독립된 메모리 영역을 할당해주기 때문에 프로세스 간 영향을 받지 않고 독립적인 작업을 수행할 수 있다
- 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없음, IPC 나 공유메모리 등의 통신기법들을 사용해야 함

[Thread]
- 스레드는 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행단위
- 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다
- 프로세스 내에서 스레드마다 각각의 Stack 만 할당받고, 나머지 Code / Data / Heap 영역은 스레드끼리 공유한다
- 스레드 간 Stack 영역에 접근할 수 없으니 스레드는 독립적인 실행흐름을 가질 수 있어 독립적인 함수 호출이 가능함

[Thread & CPU]
- 스레드는 운영체제의 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위
- 스케줄러 알고리즘에 따라 프로세스에 속한 한개의 스레드가 선점되어 CPU 에 할당됨
- 스레드 간 선점이 일어날 때 CPU 의 실행 흐름이 전환되는 컨텍스트 스위칭이 발생


[Process vs Thread]

Process
- 여러 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에 영향을 미치지 않는다. 즉, 프로그램 전체의 안정성을 확보할 수 있다
- 프로세스간 전환(컨텍스트 스위칭) 시 레지스터, 캐시 메모리 초기화 등 무거운 작업으로 인한 비용이 많이 발생한다.
- 프로세스 간 통신 기법이 어렵고 복잡해서 통신으로 인한 오버헤드가 크다
- 프로세스 생성시 독립적으로 메모리가 할당되기에 리소스 비용이 크다

Thread
- 여러 스레드 중 하나에 문제가 발생하면 전체 프로세스에 영향을 미친다
- 프로세스의 메모리 영역을 공유하기에 컨텍스트 스위칭 시간이 적고 리소스를 효율적으로 사용한다
- 스레드 간 통신비용이 적어 통신으로 인한 오버헤드가 작다
- 스레드 간 공유 메모리 영역의 동시접근으로 인한 동기화 문제가 발생한다
- 하나의 스레드에서 오류가 발생할 경우 프로세스 자체가 종료될 수 있다

<br />

#### Parallel & Concurrent

- 동시성은 특정 순서 없이 겹치는 시간에 시작, 실행 및 완료되는 여러 작업에 관한 것
- 병렬성은 멀티 코어 프로세서에서 동시에 실행되는 동일한 작업의 여러 작업에 관한 것
- 동시성과 병렬성은 비슷하지만 동일하지 않다

[동시성]
- CPU 가 한번에 많은 일을 처리하는 것에 중점을 둠. 즉 많은 작업들을 아주 빠른 시가으로 교체하면서 전체 작업을 처리
- 동시성은 작업의 처리를 빠르게 하기 위한 목적이 아닌 CPU 를 효율적으로 사용하는것에 중점을 둠
	- 스레드가 작업을 처리하다 I/O 블록에 걸린 경우 CPU 는 다른 스레드로 전환해서 작업을 진행
- 동시성은 작업에 대한 처리방식을 어떤식으로 진행할지에 대한 설계적 관점에서 이해해야함
- 동시성은 작업해야 할 수가 CPU 코어 수보다 많을 경우 해당됨, 동시성이 없다면 작업을 순차적으로 진행해야 함

[병렬성]
- 병렬성은 CPU가 동시에 많은 일을 수행하는 것에 중점을 둠. 즉 CPU 가 놀지않고 최대한 바쁘게 동작해야 함
- 병렬성은 런타임에 동시에 물리적으로 작업을 실행하는 것, 한 개의 코어에서는 절대 병렬성이 구현될 수 없음
- 병렬성은 동시성의 하위 개념으로 작업을 여러 Thread 로 분리하고, 운영체제는 그 Thread 를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것.
- 동시성이 작업 처리 방식에 대한 설계에 관한 것이라면, 병렬성은 하드웨어 계층에서 작업 수행 방식에 관한 것
- 병렬성은 작업해야 할 수가 CPU 코어 수 보다 같거나 적을 경우 가장 효율이 좋음

#### Context Switch

[개요]
- 하나의 CPU 는 동일한 시간에 하나의 작업만 수행할 수 있기에, 여러 프로세스를 동시에 실행할 수 없음
- 하나의 CPU 에서 여러 프로세스를 동시에 처리하기 위해서는 한 프로세스에서 다른 프로세스로 전환해야 하는데
이를 컨텍스트 스위치(context switch) 라고 한다

[Context]
- 프로세스 간 전환을 위해서는 이전에 어디까지 명령을 수행했고, CPU Register 에는 어떤 값이 저장되있는지에 대한 정보가 필요함
- Context 는 CPU 가 해당 프로세스를 실행하기 위한 프로세스 정보를 의미하며 이 정보들은 운영체제가 관리하는 
PCB 라고 하는 자료구조의 공간에 저장됨

[PCB (Process Control Block)]
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조
- 컨텍스트 스위칭은 CPU 가 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 일련의 과정이라 볼 수 있음

[프로세스 상태]
- 프로세스는 New(생성), Ready(준비), Running(실행), Blocked(대기), Exit(종료) 상태를 가짐
- New: 프로세스를 생성하고 있는 단계로 커널 영역에 PCB 가 만들어진 상태
- Ready: 프로세스가 CPU 를 할당받기 위해 기다리고 있는 상태
- Running: 프로세스가 CPU 를 할당받아 명령어를 실행중인 상태
- Waiting: 프로세스가 I/O 작업 완료 혹은 사건 발생을 기다리는 상태
- Terminated: 프로세스가 종료된 상태

컨텍스트 스위칭이 일어나는 조건
- 실행중인 프로세서에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 프로세스 상태가 running 에서 waiting 상태로 전이된 경우
- RoundRobin 스케줄링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때 해당 프로세스를 중지하고 다른 프로세스를 실행시켜주는 경우

[스레드 컨텍스트 스위칭]

TCB (Thread Control Block)
- Thread 상태정보를 저장하는 자료구조, PC와 Register Set(CPU 정보), 그리고 PCB 를 가리키는 포인터를 가짐
- 스레드가 하나 생성될때마다 PCB 내에서 TCB 가 생성되며 컨텍스트 스위칭이 일어나면 기존의 스레드 TCB 를 저장하고 새로운 스레드의 TCB 를 가져와 실행함

[프로세스 vs 스레드]
- 프로세스는 컨텍스트 스위칭 할 때 메모리 주소 관련 여러 처리(CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정) 등을 하기 때문에 오버헤드가 크다
- 스레드는 프로세스 내 메모리를 공유하기에 메모리 주소관련 추가적인 작업이 없어 프로세스에 비해 오버헤드가 작아 컨텍스트 스위칭이 빠르다
- 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 인해 어플리케이션 성능이 저하될 수 있음

### CPU Bound & I/O Bound

- 프로세스는 CPU 작업과 I/O 작업의 연속된 흐름으로 진행됨
- 프로세스는 CPU 명령어를 수행하다가 I/O 를 만나면 대기하고 I/O 작업이 완료되면 다시 CPU 작업을 수행함
- 특정 Task 가 완료될때까지 이 작업을 반복함

Burst
- 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것

CPU Burst
- CPU 를 연속적으로 사용하면서 명령어를 실행하는 구간
- 프로세스가 CPU 명령어를 실행하는데 소비하는 시간
- 프로세스의 RUNNING 상태를 처리

I/O Burst
- 연속적으로 I/O 를 실행하는 구간
- 프로세스가 I/O 요청 완료를 기다리는데 걸리는 시간
- 프로세스의 WAITING 상태를 처리함

CPU Bounded Process
- CPU Burst 작업이 많은 프로세스로서 I/O Burst 가 거의 없는 경우에 해당함
- 머신러닝, 블록체인, 동영상 편집 프로그램 등 CPU 연산 위주의 작업을 하는 경우를 의미
- 멀티 코어의 병렬성을 최대한 활용해서 처리 성능을 극대화 하도록 스레드를 운영, 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정

I/O Bounded Process
- I/O Burst 가 빈번히 발생하는 프로세스로서 CPU Burst 가 매우 짧음
- 파일, 키보드, DB, 네트워크 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우 해당
- CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 idle 상태가 되지 않도록 하고
최적화 된 스레드 수를 운용해서 CPU 의 효율적인 사용을 극대화

### 사용자 모드 vs 커널 모드

운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널이라고 한다

커널
- 사용자가 운영체제 위에서 실행되는 프로그램을 편하고 효율적으로 사용할 수 있게 하드웨어와 소프트웨어 간 중계자 역할을 함
- CPU, I/O 장치, 메모리, 저장소와 같은 하드웨어 자원을 프로그램에 잘 할당하는 데에 있다

운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호함
- 응용 프로그램이 하드웨어 자원에 직접 접근해 조작할 수 있다면 자원관리가 되지 않고 프로세스 간 데이터가 훼손되어
컴퓨터 시스템 전체에 오류를 가져오게 됨
- 응용 프로그램이 하드웨어 자원에 접근하려고 할때는 반드시 운영체제를 통해서만 접근하도록 해야함

CPU 권한 모드
- CPU 는 명령어를 실행할 때 크게 두가지 권한 모드로 구분해서 실행함. 바로 사용자모드와 커널모드로 구분함
- CPU 는 동작하는 동안 두가지 모드를 번갈아 가면서 수행함

사용자 모드(Mode bit = 1)
- 사용자 응용프로그램의 코드가 실행되는 모드, 메모리의 유저영역만 접근 가능
- 대부분의 응용프로그램은 입출력 장치나 파일로의 접근이 필요하기에 이 때는 유저모드에서 커널모드로 전환이 되어야 함

커널 모드(Mode bit = 0)
- 커널 영역의 코드가 실행되는 모드, 메모리의 유저영역 커널영역 모두 접근 가능
- 하드웨어 자원에 직접 접근할 수 있음

시스템 호출(System Call)
- 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이스
- 결국, 사용자모드에서 하드웨어에 접근하기 위해서는 커널모드로 변경해 접근해야 하는데 이 모드를 전환하는 것이 
System Call 이다
- 사용자 응용 프로그램은 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고
이로 인해 사용자 모드와 커널 모드를 상호 전환하며 실행하게 된다

### 사용자 수준 스레드 & 커널 수준 스레드

- 스레드는 크게 두가지 유형으로 구분됨, 사용자 수준 스레드(User Level Thread), 커널 수준 스레드(Kernel Level Thread)
- 사용자 수준 스레드는 사용자 프로그램에서 관리하고 커널 수준 스레드는 OS 에서 관리함

사용자 수준 스레드(User Level Thread)
- 사용자 영역에서 스레드 라이브러리(Pthreads, Java Thread(JVM)) 에 의해 스레드의 생성과 종료, 
스레드 스케줄링 보관 등 모든것을 관리함
- 커널은 사용자 수준 스레드에 대해 알지 못하며 단일 스레드 프로세스인것처럼 관리함

커널 수준 스레드(Kernel Level Thread)
- 스레드와 관련된 모든 작업을 관리(PCB / TCB 관리)
- 커널 스레드는 OS 스케줄러에 의해 스케줄링 됨
- CPU 는 커널에 의해 생성된 커널 스레드의 실행만 담당함


멀티스레딩 모델
- CPU 는 OS 스케줄러가 예약하는 커널 스레드만 할당받아 실행하기에 사용자 수준 스레드는 커널 수준 스레드와 매핑이 필요
- 사용자 수준 스레드는 세가지 모델로 커널 수준 스레드와 매핑하여 구현할 수 있음
	- 다대일, 일대일, 다대다 스레드 매핑

## Section 02


## 스레드 생성

- 자바 스레드는 JVM 에서 User Thread 를 생성할때 시스템 콜을 통해 커널에서 생성된 Kernel Thread 와
1:1 로 매핑되어 최종적으로 커널에서 관리됨
- JVM 에서 스레드를 생성할때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성함
- 자바에서는 Platform Thread 로 정의되어 있음, 즉 OS 플랫폼에 따라 JVM 이 사용자 스레드를 매핑하게 됨

### Thread

- void start() : 스레드 시작
- void run() : 스레드 실행 영역
- static void sleep() : 지정된 시간동안 현재 수행중인 스레드 대기
- void join() : 해당 스레드가 종료될때까지 현재 스레드 대기
- void interrupt() : 스레드에 실행 중단 신호 전달
- static boolean interrupt() : 인터럽트 상태 확인
- boolean isInterrupted() : 인터럽트 상태 확인
- void setPriority() : 스레드 우선순위 설정
- boolean isAlive() : 스레드 활성화 여부 반환
- Thread currentThread() : 현재 수행중인 스레드 객체 반환
- int activeCount: 현재 활성화되어있는 스레드 수 반환
- setDaemon : 스레드를 데몬 스레드로 설정
- State getState() : 스레드의 현재 상태 반환

### 자바 스레드

- 자바 스레드는 OS 스케줄러에 의해 실행순서가 결정됨, 스레드 실행 시점을 JVM 에서 제어할 수 없음
- 새로운 스레드는 현재 스레드와 독립적으로 실행, 최대 한번 시작, 스레드가 종료된 이후에는 다시 시작할 수 없음

#### run() 
- 스레드가 실행되면 해당 스레드에 의해 자동으로 호출되는 메소드
- public static void main(String[] args) 가 메인 스레드에 의해 자동으로 호출되는것과 비슷한 원리
- 주의할점: start() 가 아닌 run() 메소드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 
스레드의 실행스택에서 run() 이 실행될 뿐

#### 스레드 스택(Stack)
- 스레드가 생성되면 해당 스레드를 위한 스택이 만들어짐
- 스택은 각 스레드마다 독립적으로 할당되어 작동하기에 스레드 간 접근하거나 공유할 수 없음, 이는 스레드로 부터 안전하다 할 수 있음
- 스택은 각 OS 에 따라 크기가 주어지고 주어진 크기를 넘으면 StackOverFlowError 가 발생함

#### 스레드 종료
- 스레드는 run() 메소드의 코드가 모두 실행되면 자동으로 종료됨
- 스레드는 예외가 발생할 경우 종료되며, 다른 스레드에 영향을 미치지 않음
- 어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우의 종료 기준이 다름



### 스레드 생명주기와 상태

- 자바 스레드는 생성과 실행, 그리고 종료에 따른 상태를 가지고 있음, JVM 에서는 6가지의 스레드 상태가 존재.
(OS 스레드 상태를 의미하지 않음)

- 자바 스레드는 어떤 시점이든 6가지 상태 중 오직 하나의 상태를 가질 수 있음
- 자바 스레드의 현재 상태를 가져오려면 Thread 의 getState() 메서드를 사용해 가져올 수 있음
- Thread 클래스에는 스레드 상태에 대한 ENUM 상수를 제공하는 Thread.State 클래스를 제공

스레드 상태

- 객체 생성(NEW): 스레드 객체가 생성됨, 아직 시작되지 않은 스레드 상태
- 실행 대기(RUNNABLE): 실행중이거나 실행 가능한 스레드 상태
- 일시 정지(WAITING): 대기 중인 스레드 상태, 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(TIMED_WAITING): 대기 시간이 지정된 스레드 상태로서 다른 스레드가 특정 작업을 수행하기를 기다림
- 일시 정지(BLOCKED): 모니터 락(Lock) 이 해제될때까지 기다리며 차단된 스레드 상태
- 종료(TERMINATED): 실행이 완료된 스레드 상태

wait() - 다른 스레드에 의해 notify() 받을때까지 대기
join() - 스레드의 실행이 종료되거나 인터럽트가 발생할때까지 대기

## Section 03

### Java Thread Fundamentals


#### sleep()

개요
- 지정한 시간 동안 현재 스레드의 실행을 일시 정지, 대기 상태로 빠졌다가 시간이 지나면 실행대기 상태로 전환
- 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드에서 수행 후 유저모드로 전환

API 및 예외
- static sleep(long millis)
	- 지정한 밀리초 동안 스레드를 수면상태로 만듬
- static sleep(long millis, int nanos)
	- 지정한 밀리초에 나노초를 더한 시간동안 스레드를 수면 상태로 만듬
- InterruptedException
	- 스레드가 수면중에 인터럽트 될 경우 InterruptedException 예외가 발생
	- 다른 스레드는 잠자고 있는 스레드에게 인터럽트, 즉 중단 신호를 보낼 수 있음
	- InterruptedException 가 발생하면 스레드는 수면상태에서 깨어나고 실행대기 상태로 전환되어
	실행상태를 기다림

#### sleep(0) 과 sleep(n) 의 의미
- sleep() 메서드는 네이티브 메서드이기에 sleep() 이 실행되면 시스템 콜을 호출하여 유저모드에서 커널모드로 전환됨
- 다른 스레드에게 명확하게 실행을 양보하기 위함이라면 sleep(0) 보다 sleep(1) 을 사용하도록 함

sleep(0)
- 스레드가 커널모드로 전환 후 스케줄러는 현재 스레드와 동일한 우선순위의 스레드가 있을 경우 실행대기상태의 스레드에게
CPU를 할당함으로 컨텍스트 스위칭이 발생함
- 만약 우선순위가 동일한 실행대기 상태의 다른 스레드가 없으면 스케줄러는 현재 스레드에게 계속 CPU 를 할당해
컨텍스트 스위칭 없이 모드 전환만 일어남

sleep(1)
- 스레드가 커널모드로 전환 후 스케줄러는 조건에 상관없이 현재 스레드를 대기상태로 두고 다른 스레드에게
CPU 를 할당함으로 모든 전환과 함께 컨텍스트 스위칭이 발생함

#### Join
- 한 스레드가 다른 스레드가 종료될 때까지 실행을 중지하고 대기상태에 들어갔다 스레드가 종료되면 실행대기 상태로 전환됨
- 스레드의 순서를 제어하거나 다른 스레드의 작업을 기다려야하거나 순차적인 흐름을 구성하고자 할때 사용 가능
- Object 클래스의 wait() 네이티브 메서드로 연결되며 시스템 콜을 통해 커널모드로 수행, 
내부적으로 wait() & notify() 흐름을 가지고 제어함


Join 의 API 및 예외처리
- void join(): 스레드의 작업이 종료될때까지 대기 상태를 유지
- void join(long millis): 지정한 밀리초 시간동안 스레드의 대기 상태를 유지
- void join(long millis, int nanos): 지정한 밀리초에 나노초를 더한 시간동안 스레드의 대기 상태를 유지
- InterruptedException
	- 스레드가 인터럽트 될 경우 InterruptedException 예외 발생
	- 다른 스레드는 join() 을 수행중인 스레드에게 인터럽트 신호를 보낼 수 있음
	- InterruptedException 예외가 발생하면 스레드는 대기상태에서 실행대기 상태로 전환, 실행상태를 기다림

join() 의 작동방식 정리
- OS 스케줄러는 join() 을 호출한 스레드를 대기 상태로 전환하고 호출 대상 스레드에게 CPU 를 사용하도록 한다
- 호출 대상 스레드의 작업이 종료되면 join()을 호출한 스레드는 실행대기 상태로 전환되고 CPU가 실행을 재개할때까지 기다린다.
- join() 을 호출한 스레드가 실행 대기에서 실행상태가 되면 그 스레드는 남은 지점부터 실행을 다시 시작한다
- 호출 대상 스레드가 여러개일 경우 각 스레드의 작업이 종료될때까지 join() 을 호출한 스레드는 대기와 실행을 재개하는 흐름을 반복한다
- join() 을 호출한 스레드가 인터럽트되면 해당 스레드는 대기에서 해제되고 실행상태로 전환되어 예외를 처리하게 된다


#### interrupt
- 어떤 주체의 행동이나 실행흐름을 방해한다고 해석할 수 있음
- 자바 스레드에서 interrupt() 는 특정 스레드에게 인터럽트 신호를 알려줌으로서 스레드의 실행을 중단하거나 작업 취소, 강제 종료 등으로 사용할 수 있음

interrupt method
- 스레드에게 인터럽트가 발생했다는 신호를 보내는 메커니즘
- 스레드가 현재 실행흐름을 멈추고 인터럽트 이벤트를 먼저 처리하도록 시그널을 보내는 장치

InterruptedException !!
- interrupt() 메커니즘의 일부이며 대기나 차단 등 블록킹 상태에 있거나 블록킹 상태를 만나는 시점의 스레드에 인터럽트 할때 발생하는 예외
- InterruptedException 이 발생하면 인터럽트 상태는 자동으로 초기화됨, 즉 Thread.interrupted() 한것과 같은 상태로 된다
- 다른 곳에서 인터럽트 상태를 참조하고 있다면 예외 구문에서 대상 스레드에 다시 interrupt() 해야 할 수 있음
- InterruptedException 이 발생하는 케이스는 다음과 같음
	- Thread.sleep(), Thread.join(), Object.wait()
	- Future.get(), BlockingQueue.take()

스레드 우선순위 (Priority)
- 단일 CPU 에서 여러 스레드를 실행하는 것을 스케줄링이라 하며 스레드는 스케줄링에 의해 선점되어 CPU 를 할당받는다
- 자바 런타임은 고정 우선순위 선점형 스케줄링으로 알려진 매우 단순하고 결정적인 스케줄링 알고리즘 지원
(fixed-priority pre-emptive scheduling)
- 이 알고리즘은 실행 대기상태의 스레드 중 상대적인 우선순위에 따라 스레드를 예약함

우선순위 개념
- Java 에서 스레드 우선순위는 1에서 10사이의 정수이며, 정수 값이 높을수록 우선순위가 높다
- 스레드가 생성될 때 우선순위 값이 정해지며 기본 우선순위인 5로 설정됨
- 스케줄러는 우선순위가 높은 스레드를 실행하다가 해당 스레드가 중지, 양보 또는 실행 불가능이 되는 경우에
우선순위가 낮은 스레드를 실행하기 시작함
- 두 스레드의 우선순위가 같을 경우 라운드 로빈(순환할당) 스케줄링 방식에 의해 다음 스레드를 선택함
- 스레드가 반드시 우선순위가 높은 스레드를 실행한다고 보장 할 수 없음, 운영체제마다 다른 정책들이 있을 수 있으며 기아상태를 피하기 위해 스케줄러는 우선순위가 낮은 스레드를 선택할 수 있음

우선순위 유형
- 최소 우선순위: 1, public static int MIN_PRIORITY
- 기본 우선순위: 5, public static int NORM_PRIORITY
- 최대 우선순위: 10, public static int MAX_PRIORITY

우선순위 변경 및 확인
- void setPriority(int newPriority)
	- 스레드에 의해 허용되는 우선 순위 값은 1에서10사이, 이 외에 값을 설정하면 오류가 발생
	- 스레드의 우선순위를 새롭게 변경함
- int getPriority(): 스레드의 우선순위를 반환함


## Section 04



## Section 05