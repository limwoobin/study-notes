# 개발자를 위한 레디스

레디스는 싱글스레드로 동작한다. 정확히는 메인 스레드1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다.

## Chapter 03 자료구조
- 키에 저장된 아이템이 많은 경우 삭제 시 DEL 이 아니라 UNLINK 를 사용하는것이 좋다.
DEL 은 동기로 삭제되기에 싱글스레드인 레디스에서 커맨드 시간이 오래걸릴 수 있지만 UNLINK 의 경우
비동기로 백그라운드에서 키를 삭제하기 때문이다.

## Chapter 04 자료구조 활용
- SortedSet 을 이용한 실시간 리더보드 및 집계 + 가중치
- SortedSet 을 이용한 최근 검색기록 구현
- SortedSet 을 이용한 태그 기능 (그냥 Set 으로도 가능할덧)
- 랜덤 데이터 추출

카운팅 기법
- Set 으로 좋아요 처리하기
- Hash 를 이용한 채팅 안읽은 메시지 수 구하기
- 비트맵을 이용한 DAU 구하기
- HyperLogLog 를 이용한 어플리케이션 미터링
- Geo 자료구조를 이용한 위치데이터

비트맵은 뭐지?



HyperLogLog 가 뭐지?
매우 적은 메모리로 집합의 원소 개수를 추정할 수 있는 방법입니다. 집합의 원소 개수를 정확하게 계산하기 위해 아주 많은 메모리가 필요할 때나 하나의 메모리에 모두 담을 수 없을 정도로 원소의 개수가 많을 때, 정확하지 않지만 최대한 정확한 값을 상대적으로 적은 메모리만 사용해 얻고 싶을 때 사용할 수 있는 방법입니다.

해시셋과 비교했을때 약간의 오차율은 있지만 훨씬 적은메모리로 추정치를 파악할 수 있다

어떻게 처리하길래 그런걸까??
>> HyperLogLog의 핵심 아이디어는 정수의 상위 비트에 대한 확률적인 접근에서부터 시작한다. 
어떤 정수가 있을 때 상위 첫 번째 비트가 0인 정수 또는 상위 첫 번째 비트가 1인 정수는 각각 전체 표현 가능한 정수 중 50%를 차지한다. 
마찬가지로 상위 비트가 00, 01, 10, 11로 시작하는 정수 각각에 대한 최대 cardinality는 
전체 표현 가능한 정수의 25%가 된다. 
HyperLogLog에서는 이렇게 상위 몇 비트(b)를 사용할 것인지에 따라 레지스터의 개수(m=2b)가 결정된다. 
그리고 레지스터별 최대 cardinality는 '전체 표현 가능 정수 개수' × hyperlog 5개이다. 
당연히 레지스터 개수를 늘이면 좀 더 정해에 가까운 추정 값을 계산할 수 있다.


## 레디스 캐시로 사용하기

### 캐싱 전략

읽기 전략 - Look Aside 
- 가장 일반적으로 사용하는 방식
	- 찾고자 하는 데이터가 먼저 캐시에 있는지를 확인한 뒤, 캐시에 데이터가 있으면 캐시에서 읽어온다.
	- 캐시에 데이터가 없을 경우에는 직접 데이터베이스에 접근해 데이터를 조회한다.
	- 그 뒤, 어플리케이션은 이를 다시 캐시에 저장한다.
	- 장점: 레디스에 문제가 생겨 접근할 수 없는 상황이 발생하더라도 서비스 장애로 이어지지 않고 DB 를 통해 데이터를 조회할 수 있다.
	- 단점: 기존에 레디스를 통한 연결이 매우 많았다면 모든 커넥션이 DB 로 몰리기에 이슈가 발생할 수 있다


캐시를 이용한 쓰기 전략

1. write through
- DB에 업데이트 할때마다 매번 캐시에도 데이터를 함께 업데이트 시키는 방법
- 장점: 캐시는 항상 회신 데이터를 가지고 있다.
- 단점: 매번 2개의 저장소에 저장돼야 하기에 데이터를 쓸때마다 시간이 많이 소요된다

2. cache invalidation
- DB 에 값을 업데이트할때마다 캐시에서는 데이터를 삭제하는 방법
- 저장소에서는 특정 데이터를 삭제하는것이 저장하는것 보다 리소스를 적게 사용하기에 write through 의 단점을 보완한 방법

3. write behind(write back)
- 쓰기가 빈번한 상황인 경우 유용한데, 대량의 쓰기작업이 발생하면 우선 캐시에 업데이트 한 뒤, 특정 건수나 시간 간격으로 비동기로 DB 에 업데이트하는 방식
- e.g) 좋아요 기능이나 스트리밍 집계같은 기능에 유용하다


> NOTE
레디스에서는 키가 만료되었다고 바로 삭제되는것이 아님. 키는 passive 방식과 active 방식 이 두가지로 삭제됨
- passive 방식: 클라이언트가 키에 접근하고자 할때 키가 만료되었다면 메모리에서 수동적으로 삭제.
사용자가 접근할때만 수동적으로 삭제되기에 이를 passive 방식의 만료라고 함. 
그러나 사용자가 다시 접근하지 않는 경우도 있어 이 방식만으로는 충분하지 않음

- active 방식: TTL 값이 있는 키 중 20개를 랜덤하게 뽑은 뒤, 만료된 키를 모두 메모리에서 삭제함
만약 25% 이상의 키가 삭제되었다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고, 
아니라면 뽑아놓은 20개의 키 집합에서 다시 확인함. 이를 1초에 10번씩 수행


### 메모리 관리

레디스에서는 데이터의 최대 용량을 설정하는 maxmemory 설정과 이 용량을 초과할때의 처리 방식을 결정하는 
maxmemory-policy 설정값을 사용해 메모리를 관리함.

#### Noeviction (default)
- 레디스에 데이터가 가득차더라도 데이터를 삭제하지 않고 더 이상 데이터를 저장할 수 없다는 에러를 반환

#### LRU eviction
- 레디스에 데이터가 가득 찼을 때 가장 최근에 이용되지 않은 데이터부터 삭제하는 정책, 
즉 가장 오랫동안 사용되지 않은 데이터
	- volatile-lru: 만료시간이 설정되있는 키에 한해 LRU 방식으로 키를 삭제, 
	다만 모든 키가 만료시간이 없다면 noeviction 상황과 동일할수도
	- allkeys-LRU: 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제함

#### LFU eviction
- 가장 자주 사용되지 않은 데이터부터 삭제하는 정책(가장 조금 사용된 데이터)
	- volatile-lfu
	- allkeys-lfu

#### RANDOM eviction
- 레디스에 저장된 키 중 하나를 임의로 골라내 삭제, 따로 삭제될 키값을 계산하지 않아도 되어 부하를 줄여줄 수 있음
- 다만, 랜덤으로 데이터를 삭제하기에 자주 사용되는 데이터가 삭제될수도 있어서 오히려 불필요함을 유발할 수 있음
	- volatile-random
	- allkeys-random

#### volatile-ttl
- 만료시간이 가장 작은 키를 삭제


### 캐시 스탬피드 현상
- 캐시가 만료되어 여러 어플리케이션에서 동시에 DB 를 조회하고 이후 동시에 Redis 에 데이터를 쓰는 현상
이때, 연산이 많거나 한다면 DB와 어플리케이션에 순간 부하르 줄 수 있어 위험하다

### 레디스에서의 캐시와 세션스토어의 차이
- 캐시는 DB 의 완벽한 서브셋으로 동작함 즉, 캐시가 갖고있는 데이터는 모두 DB에 저장되어있으며 
캐시가 유실되더라도 해당 데이터는 DB에서 찾을 수 있음
- 캐시에 저장된 데이터는 여러 어플리케이션에서 같이 사용할 수 있음
- 세션스토어의 정보는 DB가 아닌 세션스토어에 일단 저장됨(세션이 활성화되어있는 동안에는), 
이후 유저가 로그아웃하면 데이터의 종류에 따라 DB에 저장할지 삭제될지 결정됨
- 세션스토어에 저장된 데이터는 여러 사용자 간 공유되지 않으며 특정 사용자ID 에 한해 유용함


## 레디스를 메시지 브로커로 사용하기

메시지 브로커는 크게 메시징 큐와 이벤트 스트림이라는 두가지 형태로 나눌 수 있다

메시징 큐와 이벤트 스트림의 차이
- 메시징 큐는 생산자가 소비자의 큐로 데이터를 직접 푸시, 반면 이벤트스트림은 소비자가 메시지를 pull 한다
- 메시징 큐는 소비자가 데이터를 읽어갈때 큐에서 데이터를 삭제한다, 반면 이벤트 스트림은 데이터가 바로 삭제되지 않고 특정 기간동안 저장될 수 있다
- 메시징 큐는 일대일 상황에서 한 서비스가 다른 서비스에게 동작을 지시할때 유용하게 사용될 수 있다
- 스트림은 다대다 상황에서 유리함을 확인할 수 있다

레디스의 pub/sub 은 fire-and-forget 패턴이 필요한 간단한 알림같은 서비스에서는 유용하게 쓸 수 있다

> fire-and-forget
어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고 바로 다음 코드를 실행하는 것을 의미.
주로, 성능 향상이나 비동기 작업을 수행할때 사용됨


### 클러스터 구조에서의 pub/sub
- 클러스터에서 pub/sub 을 사용할때 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에게 자동으로 전달된다. 따라서, 아무 노드에 연결해 SUBSCRIBE 커맨드를 사용하면 데이터를 수신할 수 있다.
(다만 클러스터 입장에서는 효율적인 방식은 아니다, 그래서 이를 해결하기 위해 shared pub/sub 이 나옴)

### shared pub/sub
- 각 채널은 슬롯에 매핑됨, 같은 슬롯을 가지고 있는 노드간에만 pub/sub 메시지를 전파함

### list 의 블로킹 기능
- BLPOP, BRPOP 은 각각 LPOP, RPOP 에 블로킹기능을 추가한 커맨드이다
- 이는 list 에 데이터를 요청하고 데이터가 있으면 바로 반환, 없다면 특정 시간만큼 기다렸다가 
있으면 값을 반환하고 없으면 nil 을 반환한다
- BLPOP 은 LPOP 과 다르게 두개의 데이터를 반환한다. (key, value) 왜냐하면 
여러개의 값을 기다리다가 그 중 어떤 값이 들어왔는지 알기 위해서이다