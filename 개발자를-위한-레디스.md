# 개발자를 위한 레디스

레디스는 싱글스레드로 동작한다. 정확히는 메인 스레드1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다.

## Chapter 03 자료구조
- 키에 저장된 아이템이 많은 경우 삭제 시 DEL 이 아니라 UNLINK 를 사용하는것이 좋다.
DEL 은 동기로 삭제되기에 싱글스레드인 레디스에서 커맨드 시간이 오래걸릴 수 있지만 UNLINK 의 경우
비동기로 백그라운드에서 키를 삭제하기 때문이다.

## Chapter 04 자료구조 활용
- SortedSet 을 이용한 실시간 리더보드 및 집계 + 가중치
- SortedSet 을 이용한 최근 검색기록 구현
- SortedSet 을 이용한 태그 기능 (그냥 Set 으로도 가능할덧)
- 랜덤 데이터 추출

카운팅 기법
- Set 으로 좋아요 처리하기
- Hash 를 이용한 채팅 안읽은 메시지 수 구하기
- 비트맵을 이용한 DAU 구하기
- HyperLogLog 를 이용한 어플리케이션 미터링
- Geo 자료구조를 이용한 위치데이터

비트맵은 뭐지?



HyperLogLog 가 뭐지?
매우 적은 메모리로 집합의 원소 개수를 추정할 수 있는 방법입니다. 집합의 원소 개수를 정확하게 계산하기 위해 아주 많은 메모리가 필요할 때나 하나의 메모리에 모두 담을 수 없을 정도로 원소의 개수가 많을 때, 정확하지 않지만 최대한 정확한 값을 상대적으로 적은 메모리만 사용해 얻고 싶을 때 사용할 수 있는 방법입니다.

해시셋과 비교했을때 약간의 오차율은 있지만 훨씬 적은메모리로 추정치를 파악할 수 있다

어떻게 처리하길래 그런걸까??
>> HyperLogLog의 핵심 아이디어는 정수의 상위 비트에 대한 확률적인 접근에서부터 시작한다. 
어떤 정수가 있을 때 상위 첫 번째 비트가 0인 정수 또는 상위 첫 번째 비트가 1인 정수는 각각 전체 표현 가능한 정수 중 50%를 차지한다. 
마찬가지로 상위 비트가 00, 01, 10, 11로 시작하는 정수 각각에 대한 최대 cardinality는 
전체 표현 가능한 정수의 25%가 된다. 
HyperLogLog에서는 이렇게 상위 몇 비트(b)를 사용할 것인지에 따라 레지스터의 개수(m=2b)가 결정된다. 
그리고 레지스터별 최대 cardinality는 '전체 표현 가능 정수 개수' × hyperlog 5개이다. 
당연히 레지스터 개수를 늘이면 좀 더 정해에 가까운 추정 값을 계산할 수 있다.